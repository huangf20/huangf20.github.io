<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉搜索树有多少种</title>
      <link href="2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/"/>
      <url>2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/</url>
      
        <content type="html"><![CDATA[<h2 id="给定一个整数-n，求以-1-…-n-为节点组成的二叉搜索树有多少种？"><a href="#给定一个整数-n，求以-1-…-n-为节点组成的二叉搜索树有多少种？" class="headerlink" title="给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？"></a>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</h2><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/1.png" class=""><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>定义两个函数：<br>    1.<strong>G(n)</strong>: 长度为 nn 的序列能构成的不同二叉搜索树的个数。<br>    2.<strong>F(i,n)</strong>: 以 ii 为根、序列长度为 nn 的不同二叉搜索树个数 (1≤i≤n)。</p><p>不同的二叉搜索树的总数<strong>G(n)**，是对遍历所有</strong>i (1≤i≤n)<strong>的 **F(i, n)</strong> 之和。<br>即</p><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/3.png" class=""><p>当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：<br><strong>G(0) = 1</strong>,   ,<strong>G(1)=1</strong></p><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/2.png" class=""><p>举例而言，创建以 33 为根、长度为 77 的不同二叉搜索树，整个序列是 [1, 2, 3, 4, 5, 6, 7]，我们需要从左子序列 [1, 2][1,2] 构建左子树，从右子序列 [4, 5, 6, 7] 构建右子树，然后将它们组合（即笛卡尔积）。<br>对于这个例子，不同二叉搜索树的个数为 F(3, 7)。我们将 [1,2] 构建不同左子树的数量表示为 G(2) 从 [4, 5, 6, 7] 构建不同右子树的数量表示为 G(4)，注意到 G(n) 和序列的内容无关，只和序列的长度有关。于是，F(3,7)=G(2)⋅G(4)。 因此，我们可以得到以下公式：</p><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/4.png" class=""><p>与前一公式结合，可得：</p><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/5.png" class=""><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution {    public int numTrees(int n) {        int [] G&#x3D;new int[n+1];        G[0]&#x3D;1;        G[1]&#x3D;1;        for(int i&#x3D;2;i&lt;&#x3D;n;i++){            for(int j&#x3D;1;j&lt;&#x3D;i;j++){                G[i]+&#x3D;G[j-1]*G[i-j];            }        }        return G[n];    }}</code></pre><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity启动流程</title>
      <link href="2020/09/09/activity-qi-dong-liu-cheng/"/>
      <url>2020/09/09/activity-qi-dong-liu-cheng/</url>
      
        <content type="html"><![CDATA[<img src="/2020/09/09/activity-qi-dong-liu-cheng/1.jpeg" class="" title="Activity启动流程图"><p>本篇主要讲的是从一个App启动，到Activity执行onCreate()的流程，</p><h2 id="一切从main-方法开始"><a href="#一切从main-方法开始" class="headerlink" title="一切从main()方法开始"></a>一切从main()方法开始</h2><p>Android中，一个应用程序的开始可以说是从ActivityThread.java中的main()方法中开始的，也就是java程序方法的入口：</p><pre><code>public static void main(String[] args) {        ...        Looper.prepareMainLooper();        &#x2F;&#x2F;初始化Looper        ...        ActivityThread thread &#x3D; new ActivityThread();        &#x2F;&#x2F;实例化一个ActivityThread        ...        thread.attach(false, startSeq);        &#x2F;&#x2F;这个方法最后就是为了发送出创建Application的消息        ...        Looper.loop();        &#x2F;&#x2F;主线程进入无限循环状态，等待接收消息        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);    }</code></pre><p>main()方法中主要做的事情有：<br>1.初始化主线程的 <strong>Looper</strong> 、主 <strong>Handler</strong> 。并使主线程进入等待接收Message消息的无限循环状态。<br>2.调用 <strong>attach()</strong> 方法，主要就是为了发送出初始化Application的消息。  </p><h2 id="创建Application的消息如何发送？"><a href="#创建Application的消息如何发送？" class="headerlink" title="创建Application的消息如何发送？"></a>创建Application的消息如何发送？</h2><p>ActivityThread的 <strong>attach()</strong> 方法最终的目的是发送出一条创建Application的消息—— <strong>H.BIND_APPLICATION</strong> ，到主线程的主 <strong>Handler</strong> 中。<br>attach()方法中关键代码：  </p><pre><code>private void attach(boolean system, long startSeq) {            ...            final IActivityManager mgr &#x3D; ActivityManager.getService();            &#x2F;&#x2F;获得IActivityManager实例            try {                mgr.attachApplication(mAppThread, startSeq);                &#x2F;&#x2F;又是一个方法            } catch (RemoteException ex) {                throw ex.rethrowFromSystemServer();            }            ...    }</code></pre><p>查看<strong>ActivityManager</strong>中的 <strong>getService()</strong> 方法：</p><pre><code>public static IActivityManager getService() {        return IActivityManagerSingleton.get();    }private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton &#x3D;            new Singleton&lt;IActivityManager&gt;() {                @Override                protected IActivityManager create() {                    final IBinder b &#x3D; ServiceManager.getService(Context.ACTIVITY_SERVICE);                    &#x2F;&#x2F;获得IBinder实例                    final IActivityManager am &#x3D; IActivityManager.Stub.asInterface(b);                    return am;                }            };</code></pre>  <p>可以看到, <strong>getService()</strong> 返回的是一个静态常量，它是一个单例。在其中终于获得了前面一直在用的IBinder实例。<br>获取 <strong>IBinder</strong> 的目的就是为了通过这个 <strong>IBinder</strong> 和 <strong>ActivityManager</strong> 进行通讯，进而ActivityManager会调度发送 <strong>H.BIND_APPLICATION</strong> 即初始化Application的Message消息。  </p><p>再来看看attachApplication(mAppThread)方法</p><pre><code>@Override    public final void attachApplication(IApplicationThread thread, long startSeq) {        synchronized (this) {            int callingPid &#x3D; Binder.getCallingPid();            final int callingUid &#x3D; Binder.getCallingUid();            final long origId &#x3D; Binder.clearCallingIdentity();            attachApplicationLocked(thread, callingPid, callingUid, startSeq);            Binder.restoreCallingIdentity(origId);        }    }</code></pre>  <p>attachApplicationLocked（）方法是内部的一个方法，将thread传回<strong>ActivityManager</strong>。  </p><h3 id="ApplicationThread-mAppThread"><a href="#ApplicationThread-mAppThread" class="headerlink" title="ApplicationThread mAppThread"></a>ApplicationThread mAppThread</h3><p>在ActivityThread.java 中可以看到这个变量：</p><pre><code>final ApplicationThread mAppThread &#x3D; new ApplicationThread();</code></pre>  <p>ApplicationThread.java:</p><pre><code>private class ApplicationThread extends IApplicationThread.Stub {    ...    }</code></pre> <p>attach()方法中出现的两个对象。ApplicationThread作为IApplicationThread的一个子类，承担了最后发送Activity生命周期、及其它一些消息的任务。</p><h3 id="ActivityManagerService调度发送初始化消息"><a href="#ActivityManagerService调度发送初始化消息" class="headerlink" title="ActivityManagerService调度发送初始化消息"></a>ActivityManagerService调度发送初始化消息</h3><p>ActivityManagerService中有一这样的方法：</p><pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,int pid, int callingUid, long startSeq) {         if (app.instr !&#x3D; null) {                thread.bindApplication(processName, appInfo, providers,                        app.instr.mClass,                        profilerInfo, app.instr.mArguments,                        app.instr.mWatcher,                        app.instr.mUiAutomationConnection, testMode,                        mBinderTransactionTrackingEnabled, enableTrackAllocation,                        isRestrictedBackupMode || !normalMode, app.persistent,                        new Configuration(getGlobalConfiguration()), app.compat,                        getCommonServicesLocked(app.isolated),                        mCoreSettingsObserver.getCoreSettingsLocked(),                        buildSerial, isAutofillCompatEnabled);            } else {                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,                        null, null, null, testMode,                        mBinderTransactionTrackingEnabled, enableTrackAllocation,                        isRestrictedBackupMode || !normalMode, app.persistent,                        new Configuration(getGlobalConfiguration()), app.compat,                        getCommonServicesLocked(app.isolated),                        mCoreSettingsObserver.getCoreSettingsLocked(),                        buildSerial, isAutofillCompatEnabled);            } }</code></pre> <p>ApplicationThread以IApplicationThread的身份到了ActivityManagerService中，经过一系列的操作，最终被调用了自己的bindApplication()方法，发出初始化Applicationd的消息。  </p><pre><code>public final void bindApplication(String processName, ApplicationInfo appInfo,                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,                ProfilerInfo profilerInfo, Bundle instrumentationArgs,                IInstrumentationWatcher instrumentationWatcher,                IUiAutomationConnection instrumentationUiConnection, int debugMode,                boolean enableBinderTracking, boolean trackAllocation,                boolean isRestrictedBackupMode, boolean persistent, Configuration config,                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,                String buildSerial, boolean autofillCompatibilityEnabled) {            AppBindData data &#x3D; new AppBindData();            data.processName &#x3D; processName;            data.appInfo &#x3D; appInfo;            data.providers &#x3D; providers;            data.instrumentationName &#x3D; instrumentationName;            data.instrumentationArgs &#x3D; instrumentationArgs;            data.instrumentationWatcher &#x3D; instrumentationWatcher;            data.instrumentationUiAutomationConnection &#x3D; instrumentationUiConnection;            data.debugMode &#x3D; debugMode;            data.enableBinderTracking &#x3D; enableBinderTracking;            data.trackAllocation &#x3D; trackAllocation;            data.restrictedBackupMode &#x3D; isRestrictedBackupMode;            data.persistent &#x3D; persistent;            data.config &#x3D; config;            data.compatInfo &#x3D; compatInfo;            data.initProfilerInfo &#x3D; profilerInfo;            data.buildSerial &#x3D; buildSerial;            data.autofillCompatibilityEnabled &#x3D; autofillCompatibilityEnabled;                                sendMessage(H.BIND_APPLICATION, data);        }</code></pre> <p>最后发了一条<strong>H.BIND_APPLICATION</strong>消息，接着程序开始了。  </p><h2 id="收到初始化消息之后的世界"><a href="#收到初始化消息之后的世界" class="headerlink" title="收到初始化消息之后的世界"></a>收到初始化消息之后的世界</h2><p>收到消息后都发生了些什么。上面我们已经找到初始化Applicaitond的消息是在哪发送的了。现在，需要看一看收到消息后都发生了些什么。现在找到第一个消息：<strong>H.BIND_APPLICATION</strong>。一旦接收到这个消息就开始创建Application了。这个过程是在handleBindApplication()中完成的。</p><pre><code>private void handleBindApplication(AppBindData data) {    ...    try {                final ClassLoader cl &#x3D; instrContext.getClassLoader();                mInstrumentation &#x3D; (Instrumentation)                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();                        &#x2F;&#x2F;通过反射创建Instrumentation实例            } catch (Exception e) {                throw new RuntimeException(                    &quot;Unable to instantiate instrumentation &quot;                    + data.instrumentationName + &quot;: &quot; + e.toString(), e);    ...           Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);     &#x2F;&#x2F;通过LoadedApp命令创建Application实例    ...    mInstrumentation.callApplicationOnCreate(app);    &#x2F;&#x2F;让仪器调用Application的onCreate()方法    ...}}</code></pre><h3 id="Instrumentation类"><a href="#Instrumentation类" class="headerlink" title="Instrumentation类"></a>Instrumentation类</h3><p>看看文档是怎么说的：<br>用于实现应用程序检测代码的基类。运行时打开检测后，将为您实例化该类在任何应用程序代码之前，允许您监视所有系统与应用程序的交互。仪器通过一个AndroidManifest.xml的&amp;lt；instrumentation&amp;gt；标记。  </p><img src="/2020/09/09/activity-qi-dong-liu-cheng/2.png" class="" title="Instrumentation类">  <p>打开这个类你可以发现，最终Apllication的创建，Activity的创建，以及生命周期都会经过这个对象去执行。简单点说，就是把这些操作包装了一层。通过操作Instrumentation进而实现上述的功能。<br>同时我们可看到，Instrumentation是通过反射来来实现的，而反射的ClassName就是通过Binder传递过来的。  </p><p>再来看一下<strong>callApplicationOnCreate（）</strong>方法  </p><pre><code>public void callApplicationOnCreate(Application app) {        app.onCreate();    }</code></pre><p>调用了一下Application的onCreate()方法,这就是为什么它能够起到监控的作用。  </p><p>再来看一下<strong>makeApplication（）</strong>方法</p><pre><code>public Application makeApplication(boolean forceDefaultAppClass,            Instrumentation instrumentation) {    ...    String appClass &#x3D; mApplicationInfo.className;    &#x2F;&#x2F;得到className以便反射    &#x2F;&#x2F;    ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);            app &#x3D; mActivityThread.mInstrumentation.newApplication(                    cl, appClass, appContext);    &#x2F;&#x2F;通过Instrumentation创建Application    ...           }</code></pre><p>在取得Application的实际类名之后，最终的创建工作还是交由Instrumentation去完成。  </p><h3 id="目光移回Instrumentation中的newAppliction"><a href="#目光移回Instrumentation中的newAppliction" class="headerlink" title="目光移回Instrumentation中的newAppliction()"></a>目光移回Instrumentation中的newAppliction()</h3><pre><code>public Application newApplication(ClassLoader cl, String className, Context context)            throws InstantiationException, IllegalAccessException,             ClassNotFoundException {        Application app &#x3D; getFactory(context.getPackageName())                .instantiateApplication(cl, className);        &#x2F;&#x2F;反射创建        app.attach(context);        &#x2F;&#x2F;Application被创建后第一个调用的方法,绑定Context。        return app;    }</code></pre><h2 id="LaunchActivity"><a href="#LaunchActivity" class="headerlink" title="LaunchActivity"></a>LaunchActivity</h2><p>当Application初始化完成后，系统会更具Manifests中的配置的启动Activity发送一个Intent去启动相应的Activity，处理是在ActivityThread中的handleLaunchActivity()中进行的。</p><pre><code>public Activity handleLaunchActivity(ActivityClientRecord r,            PendingTransactionActions pendingActions, Intent customIntent) {    final Activity a &#x3D; performLaunchActivity(r, customIntent);        if (a !&#x3D; null) {            r.createdConfig &#x3D; new Configuration(mConfiguration);            reportSizeConfigurations(r);            if (!r.activity.mFinished &amp;&amp; pendingActions !&#x3D; null) {                pendingActions.setOldState(r.state);                pendingActions.setRestoreInstanceState(true);                pendingActions.setCallOnPostCreate(true);            }        } else {            &#x2F;&#x2F; If there was an error, for any reason, tell the activity manager to stop us.            try {                ActivityManager.getService()                        .finishActivity(r.token, Activity.RESULT_CANCELED, null,                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);            } catch (RemoteException ex) {                throw ex.rethrowFromSystemServer();            }        }        return a;}</code></pre><p>查看一下 <strong>performLaunchActivity( )</strong> 方法</p><pre><code>private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {    ...    java.lang.ClassLoader cl &#x3D; appContext.getClassLoader();           activity &#x3D; mInstrumentation.newActivity(                   cl, component.getClassName(), r.intent);    &#x2F;&#x2F;&#x2F;&#x2F;通过仪表来创建Activity    ...    Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);    &#x2F;&#x2F;获取Application    ...    activity.attach(appContext, this, getInstrumentation(), r.token,                       r.ident, app, r.intent, r.activityInfo, title, r.parent,                       r.embeddedID, r.lastNonConfigurationInstances, config,                       r.referrer, r.voiceInteractor, window, r.configCallback);    &#x2F;&#x2F;绑定Context    ...    if (r.isPersistable()) {                   mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);               } else {                   mInstrumentation.callActivityOnCreate(activity, r.state);               }&#x2F;&#x2F;是否可持久化,通过Instrumentation来创建Activity}</code></pre><p> 到这里，从Application创建开始，到第一个Activity onCreate()结束的整个流程就结束了。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="2020/08/20/git-chang-yong-ming-ling/"/>
      <url>2020/08/20/git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>获取Git配置信息，执行以下命令：</p><pre><code>git config --list</code></pre><h3 id="仓库状态"><a href="#仓库状态" class="headerlink" title="仓库状态"></a>仓库状态</h3><pre><code>git status</code></pre><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><pre><code>git log</code></pre><p>在 Git中，用<strong>HEAD</strong>表示当前版本，也就是最新的提交commit id，上一个版本就是<strong>HEAD^</strong> ，上上一个版本就是<strong>HEAD^^</strong>，当然往上100个版本写100个^比较容易数不过来，所以写成<strong>HEAD~100</strong>。<br>现在我们要把当前版本回退到上一个版本，就可以使用<strong>git reset</strong>命令：</p><pre><code>git reset --hard HEAD^</code></pre><p>Git提供了一个命令<strong>git reflog</strong>用来记录你的每一次命令：</p><pre><code>git reflog</code></pre>  <h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>首先我们创建dev分支，然后切换到dev分支：</p><pre><code>git checkout -b dev</code></pre> <p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p><pre><code>git branch devgit checkout dev</code></pre>   <p>然后用<strong>git branch</strong>命令查看当前分支</p><pre><code>git branch</code></pre> <p>我们在<strong>dev</strong>分支上进行添加修改操作，然后我们把dev分支的工作成果合并到<strong>master</strong>分支上：</p><pre><code>git checkout mastergit merge dev</code></pre> <p>git merge命令用于合并指定分支到当前分支  </p><p>删除dev分支：</p><pre><code>git branch -d dev</code></pre> <p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。  </p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>我们只需要敲一行命令，告诉Git，以后<strong>st</strong>就表示<strong>status</strong>：</p><pre><code>git config --global alias.st status</code></pre>   <p>合并分支并线性提交历史  </p><pre><code>git checkout bugFix git rebase master</code></pre>  <img src="/2020/08/20/git-chang-yong-ming-ling/1.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/2.png" class=""><p>撤销更变： </p><h4 id="1-git-reset"><a href="#1-git-reset" class="headerlink" title="1.git reset:"></a>1.git reset:</h4><img src="/2020/08/20/git-chang-yong-ming-ling/3.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/4.png" class=""><h4 id="2-git-revert-远程分享时只能用此方法"><a href="#2-git-revert-远程分享时只能用此方法" class="headerlink" title="2.git revert(远程分享时只能用此方法)"></a>2.git revert(远程分享时只能用此方法)</h4><img src="/2020/08/20/git-chang-yong-ming-ling/5.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/6.png" class=""><h4 id="提交更变到当前的位置"><a href="#提交更变到当前的位置" class="headerlink" title="提交更变到当前的位置"></a>提交更变到当前的位置</h4><p><strong>git cherry-pick C2 C4</strong></p><img src="/2020/08/20/git-chang-yong-ming-ling/7.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/8.png" class=""><p>交互式更变提交：<br><strong>git rebase -i HEAD~4</strong></p><img src="/2020/08/20/git-chang-yong-ming-ling/9.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/10.png" class="">  <p>从远程仓库获取数据：<br><strong>git fetch</strong><br>从远程仓库获取数据并更新本地分支：<br><strong>git pull origin master</strong></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 日常开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于非UI线程更新UI</title>
      <link href="2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/"/>
      <url>2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/</url>
      
        <content type="html"><![CDATA[<p>代码如下，可以正常运行不会报错，注释中的代码加入后，报错。</p><pre><code>protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mTextView&#x3D;findViewById(R.id.tv_hello);        mTextView.setOnClickListener(this);        new Thread()        {            @Override            public void run()            {                &#x2F;*try {                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }*&#x2F;                mTextView.setText(&quot;10&quot;);            }        }.start();    }</code></pre><p>报错信息：</p><img src="/2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/0001.png" class="" title="报错信息"><p>一步步看，TextView中，setText()方法会更新UI，重点在于setText()方法中的：</p><img src="/2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/0002.png" class="" title="setText()"><p>checkForRelayout()方法，即检查是否需要更新layout，断点调试可知，不执行Thread.sleep(2000)时，mLayout为null，执行了则mLayout有值，执行checkForRelayout()方法，以至于执行后面一系列View.requestLayout、ViewRootIml.checkThread方法。<br>ViewRootIml.checkThread方法：  </p><img src="/2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/0003.png" class="" title="checkThread()"><p>  checkThread方法会检查当前线程是否为UI线程，如果不是，便抛出异常。  </p><p>  到这里，便可得出结论，这跟Activity的生命周期有关了，在onCreate()中直接开启子线程更新UI，此时View还没有画出来，用户不可见，即mLayout 为空，也就不会执行后面的方法，检查当前线程是否为UI线程了；  </p><p>  而子线程延时一段时间，此时OnResume和onStart都已经执行完成，View已经出来了，再更新UI就会执行TextView中checkForRelayout()和后面一系列方法，最后ViewRootIml的checkThread()，程序崩溃。Android要求只能在主UI线程更新UI，这是因为Android的单线程模型，View的修改若是支持多线程，那么带来的线程同步和线程安全问题难以解决。再有一点自己的理解，在一般的APP中，UI的更新都是在View绘制完成之后用户交互的时候的，那么在子线程更新UI必定会崩溃。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中dp、sp、px、pt之间的换算关系</title>
      <link href="2020/07/31/android-zhong-dp-sp-px-pt-zhi-jian-de-huan-suan-guan-xi/"/>
      <url>2020/07/31/android-zhong-dp-sp-px-pt-zhi-jian-de-huan-suan-guan-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="换算公式"><a href="#换算公式" class="headerlink" title="换算公式"></a>换算公式</h2><pre><code>1 dp &#x3D; (dpi&#x2F;160) px;1 in &#x3D; 72 pt &#x3D; dpi dp;1 pt &#x3D; dpi&#x2F;72 dp；</code></pre><p>当dpi为160（每英寸160像素点）</p><ul><li>1dp = 1px = 1sp</li><li>1in = 72pt = 160 dp</li><li>1pt = 2.22 dp；</li></ul><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>px：像素，也就是屏幕上的点；</li><li>in：英寸，长度单位；</li><li>pt：磅，长度单位，1pt=1/72in；</li><li>dp/dip：一种基于屏幕密度的抽象单位，通常用于图形的长度单位；</li><li>sp：与dp类似，通常用于字体的长度单位。</li><li>dpi：”dot per inch”,每英寸长度内的像素点；</li></ul><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典序法</title>
      <link href="2020/07/31/zi-dian-xu-fa/"/>
      <url>2020/07/31/zi-dian-xu-fa/</url>
      
        <content type="html"><![CDATA[<p>一般得到字符串的全排列使用递归暴力暴力破解的话，得到的全排列并不是按照字典序排列的，就要使用到<strong>字典序法</strong>了。<br>字典序法一般是求出当前字符串的<strong>下一个升序排列</strong>，例：</p><h3 id="A-7"><a href="#A-7" class="headerlink" title="A[7]:"></a>A[7]:</h3><img src="/2020/07/31/zi-dian-xu-fa/1.png" class="" title="A[7]"><h3 id="1-从右到左找出第一个A-i-满足A-i-lt-A-i-1-即i-1-A-i-4"><a href="#1-从右到左找出第一个A-i-满足A-i-lt-A-i-1-即i-1-A-i-4" class="headerlink" title="1.从右到左找出第一个A[i],满足A[i]&lt;A[i+1],即i=1,A[i]=4;"></a>1.从右到左找出第一个A[i],满足A[i]&lt;A[i+1],即i=1,A[i]=4;</h3><h3 id="2-从右到左找出第一个A-j-满足A-j-gt-A-i-即j-3-A-j-5"><a href="#2-从右到左找出第一个A-j-满足A-j-gt-A-i-即j-3-A-j-5" class="headerlink" title="2.从右到左找出第一个A[j],满足A[j]&gt;A[i],即j=3,A[j]=5;"></a>2.从右到左找出第一个A[j],满足A[j]&gt;A[i],即j=3,A[j]=5;</h3><h3 id="3-交换A-i-，A-j-得到："><a href="#3-交换A-i-，A-j-得到：" class="headerlink" title="3.交换A[i]，A[j],得到："></a>3.交换A[i]，A[j],得到：</h3><img src="/2020/07/31/zi-dian-xu-fa/2.png" class=""><h3 id="4-对A-i-之后的字符串进行升序排序，得到："><a href="#4-对A-i-之后的字符串进行升序排序，得到：" class="headerlink" title="4.对A[i]之后的字符串进行升序排序，得到："></a>4.对A[i]之后的字符串进行升序排序，得到：</h3><img src="/2020/07/31/zi-dian-xu-fa/3.png" class=""><p>由此，得到字符串2465321的下一个升序排序2512346。  </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>public class Solution {    public ArrayList&lt;String&gt; Permutation(String str) {        ArrayList&lt;String&gt; res &#x3D;new ArrayList&lt;String&gt;();        if(str.length()&#x3D;&#x3D;0)        {            return res;        }        res.add(str);        if(str.length()&#x3D;&#x3D;1)        {                        return res;        }        while(true)        {            str&#x3D;nextRank(str);            if(str!&#x3D;&quot;finish!&quot;)            {                res.add(str);            }            else{                break;            }        }        return res;    }    public  String nextRank(String string)    {                char ch[]&#x3D;string.toCharArray();        int i&#x3D;string.length()-2;        while(i&gt;&#x3D;0&amp;&amp;ch[i]&gt;&#x3D;ch[i+1])        {            i--;        }        if(i&#x3D;&#x3D;-1)        {            return &quot;finish!&quot;;        }        int j&#x3D;string.length()-1;                while(ch[j]&lt;&#x3D;ch[i])        {            j--;        }        char temp&#x3D;ch[i];        ch[i]&#x3D;ch[j];        ch[j]&#x3D;temp;        char[] ch1&#x3D;new char[string.length()];        for(int a&#x3D;0;a&lt;&#x3D;i;a++)        {            ch1[a]&#x3D;ch[a];        }        for(int k&#x3D;i+1, l&#x3D;0;k&lt;&#x3D;string.length()-1;k++,l++)        {            ch1[k]&#x3D;ch[string.length()-1-l];        }        return String.valueOf(ch1);            }}</code></pre><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android实现历史搜索记录效果</title>
      <link href="2020/07/20/android-shi-xian-li-shi-sou-suo-ji-lu-xiao-guo/"/>
      <url>2020/07/20/android-shi-xian-li-shi-sou-suo-ji-lu-xiao-guo/</url>
      
        <content type="html"><![CDATA[<img src="/2020/07/20/android-shi-xian-li-shi-sou-suo-ji-lu-xiao-guo/1.png" class="" title="效果图"><p>页面很简单，就是一个EditText控件，输入的时候根据已经输入的string ，select所有跟其匹配的历史记录，并且在点击之后更新到下方的TextView中。  </p><p>上代码：</p><p>reader.xml:</p><pre><code>&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;&gt;    &lt;LinearLayout        android:layout_width&#x3D;&quot;match_parent&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:orientation&#x3D;&quot;horizontal&quot;&gt;        &lt;EditText            android:id&#x3D;&quot;@+id&#x2F;et_search&quot;            android:layout_width&#x3D;&quot;wrap_content&quot;            android:layout_height&#x3D;&quot;wrap_content&quot;            android:layout_weight&#x3D;&quot;1&quot;            android:ems&#x3D;&quot;10&quot;            android:gravity&#x3D;&quot;center&quot;            android:hint&#x3D;&quot;bookId&quot;            android:singleLine&#x3D;&quot;true&quot;            android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;        &lt;Button            android:id&#x3D;&quot;@+id&#x2F;button2&quot;            android:layout_width&#x3D;&quot;wrap_content&quot;            android:layout_height&#x3D;&quot;wrap_content&quot;            android:text&#x3D;&quot;Button&quot; &#x2F;&gt;    &lt;&#x2F;LinearLayout&gt;    &lt;ScrollView        android:layout_width&#x3D;&quot;match_parent&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;&gt;        &lt;LinearLayout            android:layout_width&#x3D;&quot;match_parent&quot;            android:layout_height&#x3D;&quot;wrap_content&quot;            android:orientation&#x3D;&quot;vertical&quot; &gt;            &lt;ListView                android:id&#x3D;&quot;@+id&#x2F;listView&quot;                android:layout_width&#x3D;&quot;match_parent&quot;                android:layout_height&#x3D;&quot;250dp&quot;&gt;            &lt;&#x2F;ListView&gt;        &lt;&#x2F;LinearLayout&gt;    &lt;&#x2F;ScrollView&gt;    &lt;TextView        android:id&#x3D;&quot;@+id&#x2F;text_detail1&quot;        android:layout_width&#x3D;&quot;match_parent&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;zhaoxitech:&#x2F;&#x2F;com.zhaoxitech.cbook&#x2F;reader?bookid&#x3D;12312&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;</code></pre><p>写一个SQLite帮助类<br>RecordSQLiteOpenHelper.java</p><pre><code>public class RecordSQLiteOpenHelper extends SQLiteOpenHelper {    private static String name&#x3D;&quot;temp.db&quot;;    private static Integer version&#x3D;1;    public RecordSQLiteOpenHelper(Context context) {        super(context, name, null, version);    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(&quot;create table records(id integer primary key autoincrement,name varchar(200))&quot;);    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }}</code></pre><p>在Fragment/Activity中使用<br>这里是ReaderFragment.java  </p><pre><code>public class ReaderFragment extends Fragment {    View mView;    TextView imfoText;    EditText et_search;    ListView myListView;    RecordSQLiteOpenHelper helper;    SQLiteDatabase db;    BaseAdapter adapter;    Button button;    @Nullable    @Override    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {        mView &#x3D;inflater.inflate(R.layout.reader,container,false);        initView();        et_search.setOnKeyListener(new View.OnKeyListener() {            @Override            public boolean onKey(View v, int keyCode, KeyEvent event) {                if(keyCode&#x3D;&#x3D;KeyEvent.KEYCODE_ENTER &amp;&amp; event.getAction()&#x3D;&#x3D;KeyEvent.ACTION_DOWN)                {                    &#x2F;&#x2F;隐藏键盘                    ((InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(                            getActivity().getCurrentFocus().getWindowToken(),InputMethodManager.HIDE_NOT_ALWAYS                    );                    boolean hasdate&#x3D;hasDate(et_search.getText().toString().trim());                    if(!hasdate)                    {                        insertData(et_search.getText().toString().trim());                        queryData(&quot;&quot;);                    }                    imfoText.setText(&quot;zhaoxitech:&#x2F;&#x2F;com.zhaoxitech.cbook&#x2F;reader?bookid&#x3D;&quot;+et_search.getText().toString());                }                return false;            }        });        et_search.addTextChangedListener(new TextWatcher() {            @Override            public void beforeTextChanged(CharSequence s, int start, int count, int after) {            }            @Override            public void onTextChanged(CharSequence s, int start, int before, int count) {            }            @Override            public void afterTextChanged(Editable s) {                queryData(et_search.getText().toString());            }        });        myListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {            @Override            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {                TextView textView&#x3D;view.findViewById(android.R.id.text1);                et_search.setText(textView.getText().toString());                Toast.makeText(getContext(),textView.getText().toString(),Toast.LENGTH_SHORT).show();                imfoText.setText(&quot;zhaoxitech:&#x2F;&#x2F;com.zhaoxitech.cbook&#x2F;reader?bookid&#x3D;&quot;+textView.getText().toString());            }        });        button.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                boolean hasdate&#x3D;hasDate(et_search.getText().toString().trim());                if(!hasdate)                {                    insertData(et_search.getText().toString().trim());                    queryData(&quot;&quot;);                }                String pkgName &#x3D; &quot;com.zhaoxitech.cbook&quot;;                String bookid &#x3D; et_search.getText().toString();                Uri uri &#x3D; new Uri.Builder()                        .scheme(&quot;zhaoxitech&quot;)                        .authority(pkgName)                        .path(&quot;reader&quot;)                        .appendQueryParameter(&quot;bookId&quot;, bookid)                        .build();                imfoText.setText(uri.toString());                Intent intent &#x3D; new Intent(Intent.ACTION_VIEW);                intent.setPackage(pkgName);                intent.setData(uri);                startActivity(intent);            }        });        &#x2F;&#x2F;queryData(&quot;&quot;);        return mView;    }    private void queryData(String s) {        &#x2F;&#x2F; room        Cursor cursor&#x3D;helper.getReadableDatabase().rawQuery                (&quot;select id as _id,name from records where name like &#39;%&quot;+ s +&quot;%&#39; order by id desc&quot;,null);        adapter&#x3D;new SimpleCursorAdapter(getContext(),android.R.layout.simple_list_item_1,cursor,                new String[]{&quot;name&quot;},new int[]{android.R.id.text1}, CursorAdapter.FLAG_REGISTER_CONTENT_OBSERVER);        myListView.setAdapter(adapter);        adapter.notifyDataSetChanged();    }    private void insertData(String trim) {        db&#x3D;helper.getWritableDatabase();        db.execSQL(&quot;insert into records(name) values(&#39;&quot;+trim+&quot;&#39;)&quot;);        db.close();    }    private boolean hasDate(String tempName) {        Cursor cursor&#x3D;helper.getReadableDatabase().rawQuery(&quot;select id as _id,name from records where name &#x3D;?&quot;,new String[]{tempName});        return cursor.moveToNext();    }    private void initView() {        et_search&#x3D; mView.findViewById(R.id.et_search);        myListView&#x3D; mView.findViewById(R.id.listView);        helper&#x3D;new RecordSQLiteOpenHelper(getContext());        imfoText&#x3D; mView.findViewById(R.id.text_detail1);        button&#x3D; mView.findViewById(R.id.button2);    }}</code></pre><p>一个小坑： <strong>helper=new RecordSQLiteOpenHelper(getContext())</strong> ;<br>一开始初始化helper时，在<strong>onCreateView</strong>之前调用这句话，结果报错了，原因是Fragment在 <strong>onAttach（）</strong> 方法之前是没有和 <strong>activity</strong> 进行关联的，所以在这之前是获取不到上下文的，一定要在onCreate()之后的生命周期方法中才能调用getContext();</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> sqlite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>得到数据流的中位数</title>
      <link href="2020/07/11/de-dao-shu-ju-liu-de-zhong-wei-shu/"/>
      <url>2020/07/11/de-dao-shu-ju-liu-de-zhong-wei-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><img src="/2020/07/11/de-dao-shu-ju-liu-de-zhong-wei-shu/image.png" class=""><p>此题难点在于需要根据数据流的变化实时更新中位数，一开始想着用排序来解决，但是时间复杂度太高，于是引用了<strong>优先队列</strong>。优先队列的性质是小顶堆最小值永远在队首，大顶堆最大值永远在队首，这时我们就可以吧数据流分为两部分，一部分保存较小值，另一部分保存较大值，分别用小顶堆、大顶堆保存，那么我们需要的中位数就在两个优先队列的队首之间产生。<br>当数据数为<strong>偶数</strong>时，将数据插入小顶堆中，（确保插入的数为大顶堆队首指和这个数的较大者）<br>当数据数为<strong>奇数</strong>时，将数据插入大顶堆中，（确保插入的数为小顶堆队首指和这个数的较小者）<br>则中位数计算：<br>当数据数为<strong>奇数</strong>时，中位数等于小顶堆队首值；<br>当数据数为<strong>偶数</strong>时，中位数等于两个优先队列队首值的平均值。  </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>public class Solution {    PriorityQueue&lt;Integer&gt; low&#x3D;new PriorityQueue&lt;&gt;();    PriorityQueue&lt;Integer&gt; high&#x3D;new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            return  o2-o1;        }    });    int count &#x3D;0;    public void Insert(Integer num) {        if(count%2&#x3D;&#x3D;1){            low.offer(num);            int temp&#x3D;low.poll();            high.offer(temp);        }        else{            high.offer(num);            int temp&#x3D;high.poll();            low.offer(temp);        }        count++;    }    public Double GetMedian(){        if(count%2&#x3D;&#x3D;1){            return (double)low.peek();        }        else{            return (low.peek()+high.peek())&#x2F;2.0;        }    }}</code></pre><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView设置不同的item，并且为每个item设置监听事件</title>
      <link href="2020/07/10/recyclerview-she-zhi-bu-tong-de-item-bing-qie-wei-mei-ge-item-she-zhi-jian-ting-shi-jian/"/>
      <url>2020/07/10/recyclerview-she-zhi-bu-tong-de-item-bing-qie-wei-mei-ge-item-she-zhi-jian-ting-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>在做一个测试APP时用到的，记录一下。左方的RecyclerView是一个最简单的垂直分布的RecyclerView，右方则是一个fragment，包含着一个RecyclerView，并且每个item值变化时，上方的URL文本也随之变化，item的类型有三种，实现过程;  </p><img src="/2020/07/10/recyclerview-she-zhi-bu-tong-de-item-bing-qie-wei-mei-ge-item-she-zhi-jian-ting-shi-jian/1.png" class="" title="例图1"> <img src="/2020/07/10/recyclerview-she-zhi-bu-tong-de-item-bing-qie-wei-mei-ge-item-she-zhi-jian-ting-shi-jian/2.png" class="" title="例图2">  <h2 id="ShowFragment关键代码："><a href="#ShowFragment关键代码：" class="headerlink" title="ShowFragment关键代码："></a>ShowFragment关键代码：</h2><p>全局变量声明：</p><pre><code>private Uri.Builder mBuilder;    private String mTittle, mPath;    private View mView;    private TextView mTvContent, mTvTittle;    private RecyclerView mRecyclerView;    private Button btGo, btUpte;    private List&lt;ItemBean&gt; mItemBeanList &#x3D; new ArrayList&lt;&gt;();    private List&lt;String&gt; mValueList &#x3D; new ArrayList&lt;&gt;();</code></pre><p>数据初始化：</p><pre><code>private void initDate() {        for (int i &#x3D; 0; i &lt; mItemBeanList.size(); i++) {            mValueList.add(&quot;&quot;);        }        mBuilder &#x3D;new Uri.Builder()                .scheme(Path.scheme)                .authority(Path.pkgName)                .path(mPath);    }</code></pre><p>适配RecyclerView：</p><pre><code>private void initView() {        btGo &#x3D; mView.findViewById(R.id.bt_go);        btUpte &#x3D; mView.findViewById(R.id.bt_update);        mTvContent &#x3D; mView.findViewById(R.id.text_detial_one);        mTvTittle &#x3D; mView.findViewById(R.id.text_tittle);        mTvTittle.setText(&quot;-&quot; + mTittle + &quot;-&quot;);        mTvContent.setText(mBuilder.build().toString());        MultiItemsAdapter adapter &#x3D; new MultiItemsAdapter(this, getContext());        mRecyclerView &#x3D; mView.findViewById(R.id.rcv_vertical);        LinearLayoutManager managerVertical &#x3D; new LinearLayoutManager(getContext());        managerVertical.setOrientation(LinearLayoutManager.VERTICAL);        mRecyclerView.setLayoutManager(managerVertical);        mRecyclerView.addItemDecoration(new RecycleItemDecoration(getContext(), RecycleItemDecoration.VERTICAL_LIST));        mRecyclerView.setHasFixedSize(true);        mRecyclerView.setAdapter(adapter);        adapter.setDataList(mItemBeanList);    }</code></pre>  <p>为了接收itemBean的一个List，还要写一个接收List的构造函数：  </p><pre><code>public ShowFragment(String tittle, String content, List&lt;ItemBean&gt; list) {        mTittle &#x3D; tittle;        mPath &#x3D; content;        mItemBeanList &#x3D; list;    }</code></pre><p>其中的itemBean.java</p><pre><code>public class ItemBean {    private String tittle;    private String tittleEnglish;    private String content;    private int type;    &#x2F;&#x2F;...}</code></pre><p>ShowFragment实现一个OnItemClickListener的接口，作用是每个item中的值改变时，回调onTextChange（）方法，就可以实现改变RecyclerView外面的控件</p><pre><code>@Override    public void onTextChange(String text, int position) {        mValueList.set(position, text);        mBuilder.clearQuery();        for(int i&#x3D;0;i&lt;mValueList.size();i++)        {            if(!mValueList.get(i).equals(&quot;&quot;))            {                mBuilder.appendQueryParameter(mItemBeanList.get(i).getTittleEnglish(),mValueList.get(i));            }        }        setContentTv();    }}</code></pre><h2 id="MultiItemsAdapter关键代码："><a href="#MultiItemsAdapter关键代码：" class="headerlink" title="MultiItemsAdapter关键代码："></a>MultiItemsAdapter关键代码：</h2><p>全局变量及构造函数：</p><pre><code>public class MultiItemsAdapter extends RecyclerView.Adapter&lt;AbsViewHolder&gt; {    private OnItemClickListener mOnItemClickListener;    public OnItemClickListener getOnItemClickListener() {        return mOnItemClickListener;    }    private Context mContext;    private List&lt;ItemBean&gt; mList &#x3D; new ArrayList&lt;&gt;();    public MultiItemsAdapter(OnItemClickListener onItemClickListener, Context context) {        mOnItemClickListener &#x3D; onItemClickListener;        mContext &#x3D; context;    }    &#x2F;&#x2F;...}</code></pre><p>类中接口：</p><pre><code>public interface OnItemClickListener {        void onTextChange(String text, int position);    }}</code></pre>  <p>难点：在重写onCreateViewHolder（）和<strong>onBindViewHolder</strong>中，因为itemBean中有<strong>type</strong>这一成员变量，所以可以根据这个值来确定创建哪种item ,但是如果item种类多点，就会出现很多<strong>ifelse</strong>分支，这对我们开发来说是极其不好的，所以解决方法如下：</p><p>先创建一个抽象类AbsViewHold.java:</p><pre><code>public abstract class AbsViewHolder&lt;T extends ItemBean&gt; extends RecyclerView.ViewHolder {    private MultiItemsAdapter.OnItemClickListener mOnItemClickListener;    public AbsViewHolder(@NonNull View itemView) {        super(itemView);    }    public AbsViewHolder( MultiItemsAdapter multiItemsAdapter,@NonNull View itemView) {        super(itemView);        this.mOnItemClickListener&#x3D;multiItemsAdapter.getOnItemClickListener();    }    public abstract void bindData(T data,int position);}</code></pre>  <p>这里使用了<strong>泛型</strong>，目的是为了根据<strong>ItemData</strong>来确定<strong>ViewHolder</strong>，从而创建不同样式的item<br>创建三个不同的<strong>ViewHolder</strong>,对应三种不同的<strong>item</strong>，并且创建三个<strong>ItemData</strong>，都继承于ItemBean。  </p><p>ViewHoderA.java：</p><pre><code>public class ViewHolderA extends AbsViewHolder&lt;ItemDataA&gt; {    private MultiItemsAdapter.OnItemClickListener mOnItemClickListener;    TextView mTvTittle;    EditText mTvContent;    public ViewHolderA(MultiItemsAdapter multiItemsAdapter, View itemView) {        super(multiItemsAdapter,itemView);        this.mOnItemClickListener&#x3D;multiItemsAdapter.getOnItemClickListener();        mTvTittle &#x3D; itemView.findViewById(R.id.tv_tittle);        mTvContent &#x3D; itemView.findViewById(R.id.tv_content);    }    @Override    public void bindData(ItemDataA data, final int position) {        mTvTittle.setText(data.getTittle().toString());        mTvContent.setHint(data.getContent().toString());        mTvContent.addTextChangedListener(new TextWatcher() {            @Override            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {            }            @Override            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {            }            @Override            public void afterTextChanged(Editable editable) {                mOnItemClickListener.onTextChange(mTvContent.getText().toString(),position);            }        });    }}</code></pre>  <p>  ViewHoderB.java：  </p><pre><code>public class ViewHolderB extends AbsViewHolder&lt;ItemDataB&gt; {    private MultiItemsAdapter.OnItemClickListener mOnItemClickListener;    TextView mTvTittle;    EditText mTvContent;    public ViewHolderB(MultiItemsAdapter multiItemsAdapter, View itemView) {        super(multiItemsAdapter,itemView);        mOnItemClickListener &#x3D; multiItemsAdapter.getOnItemClickListener();        mTvTittle &#x3D; itemView.findViewById(R.id.tv_tittle2);        mTvContent &#x3D; itemView.findViewById(R.id.tv_content2);    }    @Override    public void bindData(ItemDataB data, final int position) {        mTvTittle.setText(data.getTittle().toString());        mTvContent.setHint(data.getContent().toString());        mTvContent.addTextChangedListener(new TextWatcher() {            @Override            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {            }            @Override            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {            }            @Override            public void afterTextChanged(Editable editable) {                mOnItemClickListener.onTextChange(mTvContent.getText().toString(),position);            }        });    }}</code></pre>  <p>  ViewHoderC.java：  </p><pre><code>public class ViewHolderC extends AbsViewHolder&lt;ItemDataC&gt; {    private MultiItemsAdapter.OnItemClickListener mOnItemClickListener;    TextView mTvTittle, mTvContent;    Switch aSwitch;    public ViewHolderC(MultiItemsAdapter multiItemsAdapter, View itemView) {        super(multiItemsAdapter,itemView);        mOnItemClickListener &#x3D; multiItemsAdapter.getOnItemClickListener();        mTvTittle &#x3D; itemView.findViewById(R.id.tv_tittle3);        mTvContent &#x3D; itemView.findViewById(R.id.tv_content3);        aSwitch&#x3D;itemView.findViewById(R.id.item_switch);    }    @Override    public void bindData(ItemDataC data, final int position) {        mTvTittle.setText(data.getTittle().toString());        mTvContent.setHint(data.getContent().toString());        if(data.getContent().toString().equals(&quot;true&quot;))            aSwitch.setChecked(true);        else            aSwitch.setChecked(false);        aSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {            @Override            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {                mTvContent.setText(b+&quot;&quot;);                mOnItemClickListener.onTextChange(b+&quot;&quot;,position);            }        });    }}</code></pre>  <p>这里的构造函数参数多了一个<strong>MultiItemsAdapter</strong>，这是为了将监听接口<strong>mOnItemClickListener</strong>传进来，** getOnItemClickListener() **方法在MultiItemsAdapter里实现就可以。<br>这样就实现了对每个Item监听，并且结合上文的接口、接口实现方法就可以更新RecyclerView外的控件。  </p><p>MultiItemsAdapter中重写onBindViewHolder（）方法，</p><pre><code>@Override    public void onBindViewHolder(@NonNull AbsViewHolder holder, int position) {        &#x2F;&#x2F;加一个position参数是为了监听文本框改变时，返回到实现类中，有确定的位置        holder.bindData(mList.get(position), position);    }</code></pre>  <p>直接调用** AbsViewHolder的bindData() <strong>方法，可以看到</strong> ViewHolderA，ViewHolderB,ViewHolderC <strong>中分别的</strong> bindData() <strong>方法，传入的参数是</strong> AbsViewHolder <strong>类型的，而各个实现bindData方法中的参数是</strong> ItemDataA / ItemDataB / ItemDataC <strong>,这里就是</strong>泛型<strong>的作用了，参数是超类，而传入时是ItemDataA，ItemDataB，ItemDataC这三种类型，根据这个参数创建相对应的</strong>ViewHolderA/ ViewHolderB / ViewHolderC**，从而实现创建不同样式的item的效果。</p><p>再看<strong>MultiItemsAdapter</strong>重写<strong>onCreateViewHolder</strong>的方法  </p><p>先建立映射关系，通过ArrayList：</p><pre><code>public List&lt;Class&lt;? extends ItemBean&gt;&gt; mItemTypes &#x3D; new ArrayList&lt;&gt;();    public List&lt;Class&lt;? extends AbsViewHolder&gt;&gt; mHolderTypes &#x3D; new ArrayList&lt;&gt;();    public List&lt;Integer&gt; mViewTypes &#x3D; new ArrayList&lt;&gt;();    {        registerItem(ItemDataA.class, ViewHolderA.class, R.layout.recycle_item1);        registerItem(ItemDataB.class, ViewHolderB.class, R.layout.recycle_item2);        registerItem(ItemDataC.class, ViewHolderC.class, R.layout.recycle_item3);    }    private void registerItem(Class&lt;? extends ItemBean&gt; dataClass, Class&lt;? extends AbsViewHolder&gt; holderClass, int layoutId) {        mItemTypes.add(dataClass);        mHolderTypes.add(holderClass);        mViewTypes.add(layoutId);    }   @NonNull    @Override    public AbsViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {        View view &#x3D; LayoutInflater.from(mContext).inflate(mViewTypes.get(viewType), parent, false);        Class holder &#x3D; mHolderTypes.get(viewType);  &#x2F;&#x2F;根据参数viewType来获得相对应的ViewHolder类的对象，                try {            Constructor constructor &#x3D; holder.getConstructor(MultiItemsAdapter.class, View.class);            Object absHolder &#x3D; constructor.newInstance(MultiItemsAdapter.this, view);            return (AbsViewHolder) absHolder;        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InstantiationException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        } catch (NoSuchMethodException e) {            e.printStackTrace();        }    }</code></pre><p>这里通过java中的<strong>反射</strong>机制，根据参数viewType来获得相对应的ViewHolderA / ViewHolderB / ViewHolderC类的对象，再通过<strong>getConstructor（）</strong>方法得到ViewHolderA / ViewHolderB /ViewHolderC的构造函数，通过构造函数创建对象实例返回，由此，避免了过多的ifelse分支。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/01/05/hello-world/"/>
      <url>2020/01/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
