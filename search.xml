<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目中library库打包成aar记录</title>
      <link href="2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/"/>
      <url>2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>  项目中的library库需要打包出来供其他地方使用，而普通的gradle assemble命令只能把项目本身打包，不会把依赖的jar/aar一起打包，这时候似乎只能通过gradle脚本来实现想要的效果，本身对Android编译过程和groovy不熟悉，所以参考了GitHub上两个方案。  </p><ul><li>方案1<a href="https://github.com/Mobbeel/fataar-gradle-plugin">fataar-gradle-plugin</a></li><li>方案2<a href="https://github.com/kezong/fat-aar-android">fat-aar-android</a></li></ul><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><h3 id="了解groovy语法，构建一些简单的脚本"><a href="#了解groovy语法，构建一些简单的脚本" class="headerlink" title="了解groovy语法，构建一些简单的脚本"></a>了解groovy语法，构建一些简单的脚本</h3><p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html#sec:packaging_a_plugin">官方自定义gradle脚本文档</a></p><h3 id="着手对library库进行打包"><a href="#着手对library库进行打包" class="headerlink" title="着手对library库进行打包"></a>着手对library库进行打包</h3><h4 id="方案1，fataar-gradle-plugin"><a href="#方案1，fataar-gradle-plugin" class="headerlink" title="方案1，fataar-gradle-plugin"></a>方案1，<a href="https://github.com/Mobbeel/fataar-gradle-plugin">fataar-gradle-plugin</a></h4><p>  新建一个名为buildSrc的module<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/1.png" class="" title="在项目中新建buildSrc module"><br>  将GitHub中buildSrc复制到本地项目中，然后在要打包的module的build.gradle中添加如下代码：<br>  <pre><code>apply plugin: com.mobbeel.plugin.custom </code></pre><br>  com.mobbeel.plugin.custom可以自定义名称，只需在src/main/resources/META-INF/gradle-plugins/目录下配置<strong>properties</strong>文件，文件名就是使用时的名称<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/2.png" class="" title="例：配置为com.hf.plugin.custom"></p><p>  在命令行中输入assemble命令<br>  <pre><code>gradlew :library:assemble Debug </code></pre></p><p>  然后发生错误：<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/3.png" class="" title="报错信息"><br>  <strong>解决方法</strong><br>  在DependencyProcessorPlugin.groovy中的R2ClassTask方法中加入选中代码：<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/4.png" class=""></p><p>  即可打包成功，发生错误原因：gradle版本不一致时，build生成的路径会有所差别。</p><p>  但是这个方案有个无法满足要求的点，就是此方案只能选择将全部内部的依赖打包进入aar，或者全部依赖都不打包进入aar，所以此方案不可行，寻找另一方案。</p><h4 id="方案2fat-aar-android"><a href="#方案2fat-aar-android" class="headerlink" title="方案2fat-aar-android"></a>方案2<a href="https://github.com/kezong/fat-aar-android">fat-aar-android</a></h4><p>  查看文档，这个插件可以通过embed将需要的依赖项加入最终的aar产物中，符合要求，开始配置<br>  将GitHub上源码下载至本地，把src目录拷贝至项目buildSrc中，然后在项目library的build.gradle中添加：<br>  <pre><code>apply plugin: &#39;com.kezong.fat-aar&#39; </code></pre><br>  类似地，在命令行输入assemble命令<br>  <pre><code>gradlew :library:assemble Debug </code></pre><br>  直接报错，某个方法参数类型有问题，debug开始，开启远程调试，命令行输入<br>  <pre><code>gradlew :library:assemble Debug -Dorg.gradle.daemon&#x3D;false -Dorg.gradle.debug&#x3D;true </code></pre></p><p>  debug了半天也没有找到问题在哪，最后看文档时找到了问题所在，<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/5.png" class="" title="Gradle Plugin和所需求的Gradle版本官方文档"><br>  项目用的gradle版本是4.4，而该插件在1.2.17之后就不再支持4.9以前的版本了。<br>  <strong>解决方法</strong><br>  把之前版本的源码下载到项目中，或者直接在项目build.gradle中的classpath添加该插件的依赖，就可以解决此问题。</p><p>  随后又开始打包，又遇到个错误：<br>   <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/6.png" class="" title="错误信息"></p><p>  随后根据报错信息debug<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/7.png" class="" title="debug信息"><br>  这才明白是gradle plugin的版本问题，项目的gradle plugin版本之前调试改成了3.0.0，而buildSrc的版本是3.1.3，造成冲突。<br>  <strong>解决方法</strong><br>  把项目gradle plugin版本改回至3.1.3  </p><p>  问题总是接踵而至<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/9.png" class="" title="debug信息"><br>  这个问题在处理时也是毫无头绪，只能通过错误信息在对应方法处debug，也最后在源码中找到了解决方法：<br>  <strong>解决方法</strong><br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/10.png" class="" title="源码关于处理resource冲突的方法"><br>  大体意思就是为了鼓励开发人员不使用相同的res id ，这里会报一个Duplicate resources的错误，解决方法就是在项目的<strong>gradle.properties</strong> 中添加 <strong>android.disableResourceValidation=true</strong></p><p>  最后成功打包成想要的aar包。<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/8.png" class="" title="打包成功"></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="达到预期效果"><a href="#达到预期效果" class="headerlink" title="达到预期效果"></a>达到预期效果</h3><p>  大体上达到了想要的效果，需要加入aar包的依赖、jar包，通过<strong>embed</strong>引入，不需要的就不会添加进来，但是官方文档建议不适用implementation添加依赖，容易发生版本冲突导致R类找不到，用compileOnly代替。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>  目前的问题是在别的地方引用该aar包时，build时会报错某些依赖已经存在的问题，这个问题暂时还未解决，有些依赖是嵌套的，所以只能在使用时具体情况具体去处理。<br>  <img src="/2020/11/02/xiang-mu-zhong-library-ku-da-bao-cheng-aar-ji-lu/11.png" class="" title="存在的问题"></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gradle初探，构建脚本</title>
      <link href="2020/10/22/gradle-chu-tan-gou-jian-jiao-ben/"/>
      <url>2020/10/22/gradle-chu-tan-gou-jian-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  现在的Android应用都是采用Android Studio来开发的，AS默认是采用Gradle作为构建工具的。通常开发者可以不需要理解任何Gradle的脚本配置，就可以开发出一个APP。但是，当你想做一些更智能的操作时，比如修改打包后的输出目录、提高打包速度等等，就必须对Gradle有比较深入的了解。Gradle脚本是基于Groovy语言来编译执行的，在这之前最好要对Groovy语言有所了解。</p><h2 id="build-gradle脚本"><a href="#build-gradle脚本" class="headerlink" title="build.gradle脚本"></a>build.gradle脚本</h2><p>Gradle构建脚本默认的名字是build.gradle，当在shell中执行gradle命令时，Gradle会去当前目录下寻找名字是build.gradle的文件。在Gradle中一个原子性的操作叫做task，简单理解为task是Gradle脚本中的最小可执行单元。  </p><h3 id="最简单的一个task任务"><a href="#最简单的一个task任务" class="headerlink" title="最简单的一个task任务"></a>最简单的一个task任务</h3><pre><code>class PluginDemo implements Plugin&lt;Project&gt;{    @Override    void apply(Project project) {        project.logger.error(&quot;-------------------------开始运行----------------------------&quot;)        project.task(&quot;test_task&quot;) {            println(&quot;hello world,this is a task&quot;)        }    }}apply plugin: GreetingPlugin</code></pre><p>然后在命令行输入：</p><pre><code>&gt;gradlew -q test_task&#39;-------------------------开始运行----------------------------&#39;hello world,this is a task</code></pre><h3 id="使插件可配置化"><a href="#使插件可配置化" class="headerlink" title="使插件可配置化"></a>使插件可配置化</h3><pre><code>class GreetingPluginExtension {    String message &#x3D; &#39;Hello from GreetingPlugin&#39;}class GreetingPlugin implements Plugin&lt;Project&gt; {    void apply(Project project) {        &#x2F;&#x2F; Add the &#39;greeting&#39; extension object        def extension &#x3D; project.extensions.create(&#39;greeting&#39;, GreetingPluginExtension)        &#x2F;&#x2F; Add a task that uses configuration from the extension object        project.task(&#39;hello&#39;) {            doLast {                println extension.message            }        }    }}apply plugin: GreetingPlugin&#x2F;&#x2F; Configure the extensiongreeting.message &#x3D; &#39;Hi from Gradle&#39;</code></pre><p>然后在命令行输入：</p><pre><code>&gt;gradlew -q helloHi from Gradle</code></pre><h3 id="在自定义任务和插件中处理文件"><a href="#在自定义任务和插件中处理文件" class="headerlink" title="在自定义任务和插件中处理文件"></a>在自定义任务和插件中处理文件</h3><pre><code>class GreetingToFileTask extends DefaultTask {    def destination    @OutputFile    File getDestination() {        project.file(destination)    }    @TaskAction    def greet() {        def file &#x3D; getDestination()        file.parentFile.mkdirs()        file.write &#39;Hello!&#39;    }}task greet(type: GreetingToFileTask) {    destination &#x3D; { project.greetingFile }}task sayGreeting(dependsOn: greet) {    doLast {        println file(greetingFile).text    }}ext.greetingFile &#x3D; &quot;$buildDir&#x2F;hello.txt&quot;</code></pre><p>然后在命令行输入：</p><pre><code>&gt;gradle -q sayGreetingHello</code></pre><h2 id="Gradle-构建生命周期"><a href="#Gradle-构建生命周期" class="headerlink" title="Gradle 构建生命周期"></a>Gradle 构建生命周期</h2><p>无论什么时候执行Gradle构建，都会运行3个不同的生命周期阶段：初始化、配置、执行。</p><ul><li>初始化（Initialization）<br>Gradle为每个项目创建一个Project实例，在多项目构建中，Gradle会找出哪些项目依赖需要参与到构建中。</li><li>配置（Configuration）<br>执行所有项目的构建脚本，也就是执行每个项目的build.gradle文件。这里需要注意的是，task里的配置代码也会在这个阶段执行。  </li><li>执行（Execution）<br>Gradle按照依赖顺序依次执行task。  <img src="/2020/10/22/gradle-chu-tan-gou-jian-jiao-ben/1.png" class=""><img src="/2020/10/22/gradle-chu-tan-gou-jian-jiao-ben/2.png" class=""></li></ul><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树有多少种</title>
      <link href="2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/"/>
      <url>2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/</url>
      
        <content type="html"><![CDATA[<h2 id="给定一个整数-n，求以-1-…-n-为节点组成的二叉搜索树有多少种？"><a href="#给定一个整数-n，求以-1-…-n-为节点组成的二叉搜索树有多少种？" class="headerlink" title="给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？"></a>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</h2><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/1.png" class=""><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>定义两个函数：<br>    1.<strong>G(n)</strong>: 长度为 nn 的序列能构成的不同二叉搜索树的个数。<br>    2.<strong>F(i,n)</strong>: 以 ii 为根、序列长度为 nn 的不同二叉搜索树个数 (1≤i≤n)。</p><p>不同的二叉搜索树的总数<strong>G(n)**，是对遍历所有</strong>i (1≤i≤n)<strong>的 **F(i, n)</strong> 之和。<br>即</p><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/3.png" class=""><p>当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：<br><strong>G(0) = 1</strong>,   ,<strong>G(1)=1</strong></p><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/2.png" class=""><p>举例而言，创建以 33 为根、长度为 77 的不同二叉搜索树，整个序列是 [1, 2, 3, 4, 5, 6, 7]，我们需要从左子序列 [1, 2][1,2] 构建左子树，从右子序列 [4, 5, 6, 7] 构建右子树，然后将它们组合（即笛卡尔积）。<br>对于这个例子，不同二叉搜索树的个数为 F(3, 7)。我们将 [1,2] 构建不同左子树的数量表示为 G(2) 从 [4, 5, 6, 7] 构建不同右子树的数量表示为 G(4)，注意到 G(n) 和序列的内容无关，只和序列的长度有关。于是，F(3,7)=G(2)⋅G(4)。 因此，我们可以得到以下公式：</p><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/4.png" class=""><p>与前一公式结合，可得：</p><img src="/2020/09/10/er-cha-sou-suo-shu-you-duo-shao-chong/5.png" class=""><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution {    public int numTrees(int n) {        int [] G&#x3D;new int[n+1];        G[0]&#x3D;1;        G[1]&#x3D;1;        for(int i&#x3D;2;i&lt;&#x3D;n;i++){            for(int j&#x3D;1;j&lt;&#x3D;i;j++){                G[i]+&#x3D;G[j-1]*G[i-j];            }        }        return G[n];    }}</code></pre><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity启动流程</title>
      <link href="2020/09/09/activity-qi-dong-liu-cheng/"/>
      <url>2020/09/09/activity-qi-dong-liu-cheng/</url>
      
        <content type="html"><![CDATA[<img src="/2020/09/09/activity-qi-dong-liu-cheng/1.jpeg" class="" title="Activity启动流程图"><p>本篇主要讲的是从一个App启动，到Activity执行onCreate()的流程，</p><h2 id="一切从main-方法开始"><a href="#一切从main-方法开始" class="headerlink" title="一切从main()方法开始"></a>一切从main()方法开始</h2><p>Android中，一个应用程序的开始可以说是从ActivityThread.java中的main()方法中开始的，也就是java程序方法的入口：</p><pre><code>public static void main(String[] args) {        ...        Looper.prepareMainLooper();        &#x2F;&#x2F;初始化Looper        ...        ActivityThread thread &#x3D; new ActivityThread();        &#x2F;&#x2F;实例化一个ActivityThread        ...        thread.attach(false, startSeq);        &#x2F;&#x2F;这个方法最后就是为了发送出创建Application的消息        ...        Looper.loop();        &#x2F;&#x2F;主线程进入无限循环状态，等待接收消息        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);    }</code></pre><p>main()方法中主要做的事情有：<br>1.初始化主线程的 <strong>Looper</strong> 、主 <strong>Handler</strong> 。并使主线程进入等待接收Message消息的无限循环状态。<br>2.调用 <strong>attach()</strong> 方法，主要就是为了发送出初始化Application的消息。  </p><h2 id="创建Application的消息如何发送？"><a href="#创建Application的消息如何发送？" class="headerlink" title="创建Application的消息如何发送？"></a>创建Application的消息如何发送？</h2><p>ActivityThread的 <strong>attach()</strong> 方法最终的目的是发送出一条创建Application的消息—— <strong>H.BIND_APPLICATION</strong> ，到主线程的主 <strong>Handler</strong> 中。<br>attach()方法中关键代码：  </p><pre><code>private void attach(boolean system, long startSeq) {            ...            final IActivityManager mgr &#x3D; ActivityManager.getService();            &#x2F;&#x2F;获得IActivityManager实例            try {                mgr.attachApplication(mAppThread, startSeq);                &#x2F;&#x2F;又是一个方法            } catch (RemoteException ex) {                throw ex.rethrowFromSystemServer();            }            ...    }</code></pre><p>查看<strong>ActivityManager</strong>中的 <strong>getService()</strong> 方法：</p><pre><code>public static IActivityManager getService() {        return IActivityManagerSingleton.get();    }private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton &#x3D;            new Singleton&lt;IActivityManager&gt;() {                @Override                protected IActivityManager create() {                    final IBinder b &#x3D; ServiceManager.getService(Context.ACTIVITY_SERVICE);                    &#x2F;&#x2F;获得IBinder实例                    final IActivityManager am &#x3D; IActivityManager.Stub.asInterface(b);                    return am;                }            };</code></pre>  <p>可以看到, <strong>getService()</strong> 返回的是一个静态常量，它是一个单例。在其中终于获得了前面一直在用的IBinder实例。<br>获取 <strong>IBinder</strong> 的目的就是为了通过这个 <strong>IBinder</strong> 和 <strong>ActivityManager</strong> 进行通讯，进而ActivityManager会调度发送 <strong>H.BIND_APPLICATION</strong> 即初始化Application的Message消息。  </p><p>再来看看attachApplication(mAppThread)方法</p><pre><code>@Override    public final void attachApplication(IApplicationThread thread, long startSeq) {        synchronized (this) {            int callingPid &#x3D; Binder.getCallingPid();            final int callingUid &#x3D; Binder.getCallingUid();            final long origId &#x3D; Binder.clearCallingIdentity();            attachApplicationLocked(thread, callingPid, callingUid, startSeq);            Binder.restoreCallingIdentity(origId);        }    }</code></pre>  <p>attachApplicationLocked（）方法是内部的一个方法，将thread传回<strong>ActivityManager</strong>。  </p><h3 id="ApplicationThread-mAppThread"><a href="#ApplicationThread-mAppThread" class="headerlink" title="ApplicationThread mAppThread"></a>ApplicationThread mAppThread</h3><p>在ActivityThread.java 中可以看到这个变量：</p><pre><code>final ApplicationThread mAppThread &#x3D; new ApplicationThread();</code></pre>  <p>ApplicationThread.java:</p><pre><code>private class ApplicationThread extends IApplicationThread.Stub {    ...    }</code></pre> <p>attach()方法中出现的两个对象。ApplicationThread作为IApplicationThread的一个子类，承担了最后发送Activity生命周期、及其它一些消息的任务。</p><h3 id="ActivityManagerService调度发送初始化消息"><a href="#ActivityManagerService调度发送初始化消息" class="headerlink" title="ActivityManagerService调度发送初始化消息"></a>ActivityManagerService调度发送初始化消息</h3><p>ActivityManagerService中有一这样的方法：</p><pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,int pid, int callingUid, long startSeq) {         if (app.instr !&#x3D; null) {                thread.bindApplication(processName, appInfo, providers,                        app.instr.mClass,                        profilerInfo, app.instr.mArguments,                        app.instr.mWatcher,                        app.instr.mUiAutomationConnection, testMode,                        mBinderTransactionTrackingEnabled, enableTrackAllocation,                        isRestrictedBackupMode || !normalMode, app.persistent,                        new Configuration(getGlobalConfiguration()), app.compat,                        getCommonServicesLocked(app.isolated),                        mCoreSettingsObserver.getCoreSettingsLocked(),                        buildSerial, isAutofillCompatEnabled);            } else {                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,                        null, null, null, testMode,                        mBinderTransactionTrackingEnabled, enableTrackAllocation,                        isRestrictedBackupMode || !normalMode, app.persistent,                        new Configuration(getGlobalConfiguration()), app.compat,                        getCommonServicesLocked(app.isolated),                        mCoreSettingsObserver.getCoreSettingsLocked(),                        buildSerial, isAutofillCompatEnabled);            } }</code></pre> <p>ApplicationThread以IApplicationThread的身份到了ActivityManagerService中，经过一系列的操作，最终被调用了自己的bindApplication()方法，发出初始化Applicationd的消息。  </p><pre><code>public final void bindApplication(String processName, ApplicationInfo appInfo,                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,                ProfilerInfo profilerInfo, Bundle instrumentationArgs,                IInstrumentationWatcher instrumentationWatcher,                IUiAutomationConnection instrumentationUiConnection, int debugMode,                boolean enableBinderTracking, boolean trackAllocation,                boolean isRestrictedBackupMode, boolean persistent, Configuration config,                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,                String buildSerial, boolean autofillCompatibilityEnabled) {            AppBindData data &#x3D; new AppBindData();            data.processName &#x3D; processName;            data.appInfo &#x3D; appInfo;            data.providers &#x3D; providers;            data.instrumentationName &#x3D; instrumentationName;            data.instrumentationArgs &#x3D; instrumentationArgs;            data.instrumentationWatcher &#x3D; instrumentationWatcher;            data.instrumentationUiAutomationConnection &#x3D; instrumentationUiConnection;            data.debugMode &#x3D; debugMode;            data.enableBinderTracking &#x3D; enableBinderTracking;            data.trackAllocation &#x3D; trackAllocation;            data.restrictedBackupMode &#x3D; isRestrictedBackupMode;            data.persistent &#x3D; persistent;            data.config &#x3D; config;            data.compatInfo &#x3D; compatInfo;            data.initProfilerInfo &#x3D; profilerInfo;            data.buildSerial &#x3D; buildSerial;            data.autofillCompatibilityEnabled &#x3D; autofillCompatibilityEnabled;                                sendMessage(H.BIND_APPLICATION, data);        }</code></pre> <p>最后发了一条<strong>H.BIND_APPLICATION</strong>消息，接着程序开始了。  </p><h2 id="收到初始化消息之后的世界"><a href="#收到初始化消息之后的世界" class="headerlink" title="收到初始化消息之后的世界"></a>收到初始化消息之后的世界</h2><p>收到消息后都发生了些什么。上面我们已经找到初始化Applicaitond的消息是在哪发送的了。现在，需要看一看收到消息后都发生了些什么。现在找到第一个消息：<strong>H.BIND_APPLICATION</strong>。一旦接收到这个消息就开始创建Application了。这个过程是在handleBindApplication()中完成的。</p><pre><code>private void handleBindApplication(AppBindData data) {    ...    try {                final ClassLoader cl &#x3D; instrContext.getClassLoader();                mInstrumentation &#x3D; (Instrumentation)                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();                        &#x2F;&#x2F;通过反射创建Instrumentation实例            } catch (Exception e) {                throw new RuntimeException(                    &quot;Unable to instantiate instrumentation &quot;                    + data.instrumentationName + &quot;: &quot; + e.toString(), e);    ...           Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);     &#x2F;&#x2F;通过LoadedApp命令创建Application实例    ...    mInstrumentation.callApplicationOnCreate(app);    &#x2F;&#x2F;让仪器调用Application的onCreate()方法    ...}}</code></pre><h3 id="Instrumentation类"><a href="#Instrumentation类" class="headerlink" title="Instrumentation类"></a>Instrumentation类</h3><p>看看文档是怎么说的：<br>用于实现应用程序检测代码的基类。运行时打开检测后，将为您实例化该类在任何应用程序代码之前，允许您监视所有系统与应用程序的交互。仪器通过一个AndroidManifest.xml的&amp;lt；instrumentation&amp;gt；标记。  </p><img src="/2020/09/09/activity-qi-dong-liu-cheng/2.png" class="" title="Instrumentation类">  <p>打开这个类你可以发现，最终Apllication的创建，Activity的创建，以及生命周期都会经过这个对象去执行。简单点说，就是把这些操作包装了一层。通过操作Instrumentation进而实现上述的功能。<br>同时我们可看到，Instrumentation是通过反射来来实现的，而反射的ClassName就是通过Binder传递过来的。  </p><p>再来看一下<strong>callApplicationOnCreate（）</strong>方法  </p><pre><code>public void callApplicationOnCreate(Application app) {        app.onCreate();    }</code></pre><p>调用了一下Application的onCreate()方法,这就是为什么它能够起到监控的作用。  </p><p>再来看一下<strong>makeApplication（）</strong>方法</p><pre><code>public Application makeApplication(boolean forceDefaultAppClass,            Instrumentation instrumentation) {    ...    String appClass &#x3D; mApplicationInfo.className;    &#x2F;&#x2F;得到className以便反射    &#x2F;&#x2F;    ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);            app &#x3D; mActivityThread.mInstrumentation.newApplication(                    cl, appClass, appContext);    &#x2F;&#x2F;通过Instrumentation创建Application    ...           }</code></pre><p>在取得Application的实际类名之后，最终的创建工作还是交由Instrumentation去完成。  </p><h3 id="目光移回Instrumentation中的newAppliction"><a href="#目光移回Instrumentation中的newAppliction" class="headerlink" title="目光移回Instrumentation中的newAppliction()"></a>目光移回Instrumentation中的newAppliction()</h3><pre><code>public Application newApplication(ClassLoader cl, String className, Context context)            throws InstantiationException, IllegalAccessException,             ClassNotFoundException {        Application app &#x3D; getFactory(context.getPackageName())                .instantiateApplication(cl, className);        &#x2F;&#x2F;反射创建        app.attach(context);        &#x2F;&#x2F;Application被创建后第一个调用的方法,绑定Context。        return app;    }</code></pre><h2 id="LaunchActivity"><a href="#LaunchActivity" class="headerlink" title="LaunchActivity"></a>LaunchActivity</h2><p>当Application初始化完成后，系统会更具Manifests中的配置的启动Activity发送一个Intent去启动相应的Activity，处理是在ActivityThread中的handleLaunchActivity()中进行的。</p><pre><code>public Activity handleLaunchActivity(ActivityClientRecord r,            PendingTransactionActions pendingActions, Intent customIntent) {    final Activity a &#x3D; performLaunchActivity(r, customIntent);        if (a !&#x3D; null) {            r.createdConfig &#x3D; new Configuration(mConfiguration);            reportSizeConfigurations(r);            if (!r.activity.mFinished &amp;&amp; pendingActions !&#x3D; null) {                pendingActions.setOldState(r.state);                pendingActions.setRestoreInstanceState(true);                pendingActions.setCallOnPostCreate(true);            }        } else {            &#x2F;&#x2F; If there was an error, for any reason, tell the activity manager to stop us.            try {                ActivityManager.getService()                        .finishActivity(r.token, Activity.RESULT_CANCELED, null,                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);            } catch (RemoteException ex) {                throw ex.rethrowFromSystemServer();            }        }        return a;}</code></pre><p>查看一下 <strong>performLaunchActivity( )</strong> 方法</p><pre><code>private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {    ...    java.lang.ClassLoader cl &#x3D; appContext.getClassLoader();           activity &#x3D; mInstrumentation.newActivity(                   cl, component.getClassName(), r.intent);    &#x2F;&#x2F;&#x2F;&#x2F;通过仪表来创建Activity    ...    Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);    &#x2F;&#x2F;获取Application    ...    activity.attach(appContext, this, getInstrumentation(), r.token,                       r.ident, app, r.intent, r.activityInfo, title, r.parent,                       r.embeddedID, r.lastNonConfigurationInstances, config,                       r.referrer, r.voiceInteractor, window, r.configCallback);    &#x2F;&#x2F;绑定Context    ...    if (r.isPersistable()) {                   mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);               } else {                   mInstrumentation.callActivityOnCreate(activity, r.state);               }&#x2F;&#x2F;是否可持久化,通过Instrumentation来创建Activity}</code></pre><p> 到这里，从Application创建开始，到第一个Activity onCreate()结束的整个流程就结束了。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http状态码及其含义</title>
      <link href="2020/08/26/http-zhuang-tai-ma-ji-qi-han-yi/"/>
      <url>2020/08/26/http-zhuang-tai-ma-ji-qi-han-yi/</url>
      
        <content type="html"><![CDATA[<h4 id="其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。"><a href="#其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。" class="headerlink" title="其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。"></a>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</h4><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。<h4 id="常见状态代码、状态描述的说明如下。"><a href="#常见状态代码、状态描述的说明如下。" class="headerlink" title="常见状态代码、状态描述的说明如下。"></a>常见状态代码、状态描述的说明如下。</h4></li><li>200 OK：客户端请求成功。</li><li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li><li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li><li>500 Internal Server Error：服务器发生不可预期的错误。</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li></ul><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="2020/08/20/git-chang-yong-ming-ling/"/>
      <url>2020/08/20/git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>获取Git配置信息，执行以下命令：</p><pre><code>git config --list</code></pre><h3 id="仓库状态"><a href="#仓库状态" class="headerlink" title="仓库状态"></a>仓库状态</h3><pre><code>git status</code></pre><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><pre><code>git log</code></pre><p>在 Git中，用<strong>HEAD</strong>表示当前版本，也就是最新的提交commit id，上一个版本就是<strong>HEAD^</strong> ，上上一个版本就是<strong>HEAD^^</strong>，当然往上100个版本写100个^比较容易数不过来，所以写成<strong>HEAD~100</strong>。<br>现在我们要把当前版本回退到上一个版本，就可以使用<strong>git reset</strong>命令：</p><pre><code>git reset --hard HEAD^</code></pre><p>Git提供了一个命令<strong>git reflog</strong>用来记录你的每一次命令：</p><pre><code>git reflog</code></pre>  <h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>首先我们创建dev分支，然后切换到dev分支：</p><pre><code>git checkout -b dev</code></pre> <p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p><pre><code>git branch devgit checkout dev</code></pre>   <p>然后用<strong>git branch</strong>命令查看当前分支</p><pre><code>git branch</code></pre> <p>我们在<strong>dev</strong>分支上进行添加修改操作，然后我们把dev分支的工作成果合并到<strong>master</strong>分支上：</p><pre><code>git checkout mastergit merge dev</code></pre> <p>git merge命令用于合并指定分支到当前分支  </p><p>删除dev分支：</p><pre><code>git branch -d dev</code></pre> <p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。  </p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>我们只需要敲一行命令，告诉Git，以后<strong>st</strong>就表示<strong>status</strong>：</p><pre><code>git config --global alias.st status</code></pre>   <p>合并分支并线性提交历史  </p><pre><code>git checkout bugFix git rebase master</code></pre>  <img src="/2020/08/20/git-chang-yong-ming-ling/1.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/2.png" class=""><p>撤销更变： </p><h4 id="1-git-reset"><a href="#1-git-reset" class="headerlink" title="1.git reset:"></a>1.git reset:</h4><img src="/2020/08/20/git-chang-yong-ming-ling/3.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/4.png" class=""><h4 id="2-git-revert-远程分享时只能用此方法"><a href="#2-git-revert-远程分享时只能用此方法" class="headerlink" title="2.git revert(远程分享时只能用此方法)"></a>2.git revert(远程分享时只能用此方法)</h4><img src="/2020/08/20/git-chang-yong-ming-ling/5.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/6.png" class=""><h4 id="提交更变到当前的位置"><a href="#提交更变到当前的位置" class="headerlink" title="提交更变到当前的位置"></a>提交更变到当前的位置</h4><p><strong>git cherry-pick C2 C4</strong></p><img src="/2020/08/20/git-chang-yong-ming-ling/7.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/8.png" class=""><p>交互式更变提交：<br><strong>git rebase -i HEAD~4</strong></p><img src="/2020/08/20/git-chang-yong-ming-ling/9.png" class=""> ------> <img src="/2020/08/20/git-chang-yong-ming-ling/10.png" class="">  <p>从远程仓库获取数据：<br><strong>git fetch</strong><br>从远程仓库获取数据并更新本地分支：<br><strong>git pull origin master</strong></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 日常开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于非UI线程更新UI</title>
      <link href="2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/"/>
      <url>2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/</url>
      
        <content type="html"><![CDATA[<p>代码如下，可以正常运行不会报错，注释中的代码加入后，报错。</p><pre><code>protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mTextView&#x3D;findViewById(R.id.tv_hello);        mTextView.setOnClickListener(this);        new Thread()        {            @Override            public void run()            {                &#x2F;*try {                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }*&#x2F;                mTextView.setText(&quot;10&quot;);            }        }.start();    }</code></pre><p>报错信息：</p><img src="/2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/0001.png" class="" title="报错信息"><p>一步步看，TextView中，setText()方法会更新UI，重点在于setText()方法中的：</p><img src="/2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/0002.png" class="" title="setText()"><p>checkForRelayout()方法，即检查是否需要更新layout，断点调试可知，不执行Thread.sleep(2000)时，mLayout为null，执行了则mLayout有值，执行checkForRelayout()方法，以至于执行后面一系列View.requestLayout、ViewRootIml.checkThread方法。<br>ViewRootIml.checkThread方法：  </p><img src="/2020/08/09/guan-yu-fei-ui-xian-cheng-geng-xin-ui/0003.png" class="" title="checkThread()"><p>  checkThread方法会检查当前线程是否为UI线程，如果不是，便抛出异常。  </p><p>  到这里，便可得出结论，这跟Activity的生命周期有关了，在onCreate()中直接开启子线程更新UI，此时View还没有画出来，用户不可见，即mLayout 为空，也就不会执行后面的方法，检查当前线程是否为UI线程了；  </p><p>  而子线程延时一段时间，此时OnResume和onStart都已经执行完成，View已经出来了，再更新UI就会执行TextView中checkForRelayout()和后面一系列方法，最后ViewRootIml的checkThread()，程序崩溃。Android要求只能在主UI线程更新UI，这是因为Android的单线程模型，View的修改若是支持多线程，那么带来的线程同步和线程安全问题难以解决。再有一点自己的理解，在一般的APP中，UI的更新都是在View绘制完成之后用户交互的时候的，那么在子线程更新UI必定会崩溃。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中dp、sp、px、pt之间的换算关系</title>
      <link href="2020/07/31/android-zhong-dp-sp-px-pt-zhi-jian-de-huan-suan-guan-xi/"/>
      <url>2020/07/31/android-zhong-dp-sp-px-pt-zhi-jian-de-huan-suan-guan-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="换算公式"><a href="#换算公式" class="headerlink" title="换算公式"></a>换算公式</h2><pre><code>1 dp &#x3D; (dpi&#x2F;160) px;1 in &#x3D; 72 pt &#x3D; dpi dp;1 pt &#x3D; dpi&#x2F;72 dp；</code></pre><p>当dpi为160（每英寸160像素点）</p><ul><li>1dp = 1px = 1sp</li><li>1in = 72pt = 160 dp</li><li>1pt = 2.22 dp；</li></ul><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>px：像素，也就是屏幕上的点；</li><li>in：英寸，长度单位；</li><li>pt：磅，长度单位，1pt=1/72in；</li><li>dp/dip：一种基于屏幕密度的抽象单位，通常用于图形的长度单位；</li><li>sp：与dp类似，通常用于字体的长度单位。</li><li>dpi：”dot per inch”,每英寸长度内的像素点；</li></ul><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典序法</title>
      <link href="2020/07/31/zi-dian-xu-fa/"/>
      <url>2020/07/31/zi-dian-xu-fa/</url>
      
        <content type="html"><![CDATA[<p>一般得到字符串的全排列使用递归暴力暴力破解的话，得到的全排列并不是按照字典序排列的，就要使用到<strong>字典序法</strong>了。<br>字典序法一般是求出当前字符串的<strong>下一个升序排列</strong>，例：</p><h3 id="A-7"><a href="#A-7" class="headerlink" title="A[7]:"></a>A[7]:</h3><img src="/2020/07/31/zi-dian-xu-fa/1.png" class="" title="A[7]"><h3 id="1-从右到左找出第一个A-i-满足A-i-lt-A-i-1-即i-1-A-i-4"><a href="#1-从右到左找出第一个A-i-满足A-i-lt-A-i-1-即i-1-A-i-4" class="headerlink" title="1.从右到左找出第一个A[i],满足A[i]&lt;A[i+1],即i=1,A[i]=4;"></a>1.从右到左找出第一个A[i],满足A[i]&lt;A[i+1],即i=1,A[i]=4;</h3><h3 id="2-从右到左找出第一个A-j-满足A-j-gt-A-i-即j-3-A-j-5"><a href="#2-从右到左找出第一个A-j-满足A-j-gt-A-i-即j-3-A-j-5" class="headerlink" title="2.从右到左找出第一个A[j],满足A[j]&gt;A[i],即j=3,A[j]=5;"></a>2.从右到左找出第一个A[j],满足A[j]&gt;A[i],即j=3,A[j]=5;</h3><h3 id="3-交换A-i-，A-j-得到："><a href="#3-交换A-i-，A-j-得到：" class="headerlink" title="3.交换A[i]，A[j],得到："></a>3.交换A[i]，A[j],得到：</h3><img src="/2020/07/31/zi-dian-xu-fa/2.png" class=""><h3 id="4-对A-i-之后的字符串进行升序排序，得到："><a href="#4-对A-i-之后的字符串进行升序排序，得到：" class="headerlink" title="4.对A[i]之后的字符串进行升序排序，得到："></a>4.对A[i]之后的字符串进行升序排序，得到：</h3><img src="/2020/07/31/zi-dian-xu-fa/3.png" class=""><p>由此，得到字符串2465321的下一个升序排序2512346。  </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>public class Solution {    public ArrayList&lt;String&gt; Permutation(String str) {        ArrayList&lt;String&gt; res &#x3D;new ArrayList&lt;String&gt;();        if(str.length()&#x3D;&#x3D;0)        {            return res;        }        res.add(str);        if(str.length()&#x3D;&#x3D;1)        {                        return res;        }        while(true)        {            str&#x3D;nextRank(str);            if(str!&#x3D;&quot;finish!&quot;)            {                res.add(str);            }            else{                break;            }        }        return res;    }    public  String nextRank(String string)    {                char ch[]&#x3D;string.toCharArray();        int i&#x3D;string.length()-2;        while(i&gt;&#x3D;0&amp;&amp;ch[i]&gt;&#x3D;ch[i+1])        {            i--;        }        if(i&#x3D;&#x3D;-1)        {            return &quot;finish!&quot;;        }        int j&#x3D;string.length()-1;                while(ch[j]&lt;&#x3D;ch[i])        {            j--;        }        char temp&#x3D;ch[i];        ch[i]&#x3D;ch[j];        ch[j]&#x3D;temp;        char[] ch1&#x3D;new char[string.length()];        for(int a&#x3D;0;a&lt;&#x3D;i;a++)        {            ch1[a]&#x3D;ch[a];        }        for(int k&#x3D;i+1, l&#x3D;0;k&lt;&#x3D;string.length()-1;k++,l++)        {            ch1[k]&#x3D;ch[string.length()-1-l];        }        return String.valueOf(ch1);            }}</code></pre><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android实现历史搜索记录效果</title>
      <link href="2020/07/20/android-shi-xian-li-shi-sou-suo-ji-lu-xiao-guo/"/>
      <url>2020/07/20/android-shi-xian-li-shi-sou-suo-ji-lu-xiao-guo/</url>
      
        <content type="html"><![CDATA[<img src="/2020/07/20/android-shi-xian-li-shi-sou-suo-ji-lu-xiao-guo/1.png" class="" title="效果图"><p>页面很简单，就是一个EditText控件，输入的时候根据已经输入的string ，select所有跟其匹配的历史记录，并且在点击之后更新到下方的TextView中。  </p><p>上代码：</p><p>reader.xml:</p><pre><code>&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;&gt;    &lt;LinearLayout        android:layout_width&#x3D;&quot;match_parent&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:orientation&#x3D;&quot;horizontal&quot;&gt;        &lt;EditText            android:id&#x3D;&quot;@+id&#x2F;et_search&quot;            android:layout_width&#x3D;&quot;wrap_content&quot;            android:layout_height&#x3D;&quot;wrap_content&quot;            android:layout_weight&#x3D;&quot;1&quot;            android:ems&#x3D;&quot;10&quot;            android:gravity&#x3D;&quot;center&quot;            android:hint&#x3D;&quot;bookId&quot;            android:singleLine&#x3D;&quot;true&quot;            android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;        &lt;Button            android:id&#x3D;&quot;@+id&#x2F;button2&quot;            android:layout_width&#x3D;&quot;wrap_content&quot;            android:layout_height&#x3D;&quot;wrap_content&quot;            android:text&#x3D;&quot;Button&quot; &#x2F;&gt;    &lt;&#x2F;LinearLayout&gt;    &lt;ScrollView        android:layout_width&#x3D;&quot;match_parent&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;&gt;        &lt;LinearLayout            android:layout_width&#x3D;&quot;match_parent&quot;            android:layout_height&#x3D;&quot;wrap_content&quot;            android:orientation&#x3D;&quot;vertical&quot; &gt;            &lt;ListView                android:id&#x3D;&quot;@+id&#x2F;listView&quot;                android:layout_width&#x3D;&quot;match_parent&quot;                android:layout_height&#x3D;&quot;250dp&quot;&gt;            &lt;&#x2F;ListView&gt;        &lt;&#x2F;LinearLayout&gt;    &lt;&#x2F;ScrollView&gt;    &lt;TextView        android:id&#x3D;&quot;@+id&#x2F;text_detail1&quot;        android:layout_width&#x3D;&quot;match_parent&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;zhaoxitech:&#x2F;&#x2F;com.zhaoxitech.cbook&#x2F;reader?bookid&#x3D;12312&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;</code></pre><p>写一个SQLite帮助类<br>RecordSQLiteOpenHelper.java</p><pre><code>public class RecordSQLiteOpenHelper extends SQLiteOpenHelper {    private static String name&#x3D;&quot;temp.db&quot;;    private static Integer version&#x3D;1;    public RecordSQLiteOpenHelper(Context context) {        super(context, name, null, version);    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(&quot;create table records(id integer primary key autoincrement,name varchar(200))&quot;);    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }}</code></pre><p>在Fragment/Activity中使用<br>这里是ReaderFragment.java  </p><pre><code>public class ReaderFragment extends Fragment {    View mView;    TextView imfoText;    EditText et_search;    ListView myListView;    RecordSQLiteOpenHelper helper;    SQLiteDatabase db;    BaseAdapter adapter;    Button button;    @Nullable    @Override    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {        mView &#x3D;inflater.inflate(R.layout.reader,container,false);        initView();        et_search.setOnKeyListener(new View.OnKeyListener() {            @Override            public boolean onKey(View v, int keyCode, KeyEvent event) {                if(keyCode&#x3D;&#x3D;KeyEvent.KEYCODE_ENTER &amp;&amp; event.getAction()&#x3D;&#x3D;KeyEvent.ACTION_DOWN)                {                    &#x2F;&#x2F;隐藏键盘                    ((InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(                            getActivity().getCurrentFocus().getWindowToken(),InputMethodManager.HIDE_NOT_ALWAYS                    );                    boolean hasdate&#x3D;hasDate(et_search.getText().toString().trim());                    if(!hasdate)                    {                        insertData(et_search.getText().toString().trim());                        queryData(&quot;&quot;);                    }                    imfoText.setText(&quot;zhaoxitech:&#x2F;&#x2F;com.zhaoxitech.cbook&#x2F;reader?bookid&#x3D;&quot;+et_search.getText().toString());                }                return false;            }        });        et_search.addTextChangedListener(new TextWatcher() {            @Override            public void beforeTextChanged(CharSequence s, int start, int count, int after) {            }            @Override            public void onTextChanged(CharSequence s, int start, int before, int count) {            }            @Override            public void afterTextChanged(Editable s) {                queryData(et_search.getText().toString());            }        });        myListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {            @Override            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {                TextView textView&#x3D;view.findViewById(android.R.id.text1);                et_search.setText(textView.getText().toString());                Toast.makeText(getContext(),textView.getText().toString(),Toast.LENGTH_SHORT).show();                imfoText.setText(&quot;zhaoxitech:&#x2F;&#x2F;com.zhaoxitech.cbook&#x2F;reader?bookid&#x3D;&quot;+textView.getText().toString());            }        });        button.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                boolean hasdate&#x3D;hasDate(et_search.getText().toString().trim());                if(!hasdate)                {                    insertData(et_search.getText().toString().trim());                    queryData(&quot;&quot;);                }                String pkgName &#x3D; &quot;com.zhaoxitech.cbook&quot;;                String bookid &#x3D; et_search.getText().toString();                Uri uri &#x3D; new Uri.Builder()                        .scheme(&quot;zhaoxitech&quot;)                        .authority(pkgName)                        .path(&quot;reader&quot;)                        .appendQueryParameter(&quot;bookId&quot;, bookid)                        .build();                imfoText.setText(uri.toString());                Intent intent &#x3D; new Intent(Intent.ACTION_VIEW);                intent.setPackage(pkgName);                intent.setData(uri);                startActivity(intent);            }        });        &#x2F;&#x2F;queryData(&quot;&quot;);        return mView;    }    private void queryData(String s) {        &#x2F;&#x2F; room        Cursor cursor&#x3D;helper.getReadableDatabase().rawQuery                (&quot;select id as _id,name from records where name like &#39;%&quot;+ s +&quot;%&#39; order by id desc&quot;,null);        adapter&#x3D;new SimpleCursorAdapter(getContext(),android.R.layout.simple_list_item_1,cursor,                new String[]{&quot;name&quot;},new int[]{android.R.id.text1}, CursorAdapter.FLAG_REGISTER_CONTENT_OBSERVER);        myListView.setAdapter(adapter);        adapter.notifyDataSetChanged();    }    private void insertData(String trim) {        db&#x3D;helper.getWritableDatabase();        db.execSQL(&quot;insert into records(name) values(&#39;&quot;+trim+&quot;&#39;)&quot;);        db.close();    }    private boolean hasDate(String tempName) {        Cursor cursor&#x3D;helper.getReadableDatabase().rawQuery(&quot;select id as _id,name from records where name &#x3D;?&quot;,new String[]{tempName});        return cursor.moveToNext();    }    private void initView() {        et_search&#x3D; mView.findViewById(R.id.et_search);        myListView&#x3D; mView.findViewById(R.id.listView);        helper&#x3D;new RecordSQLiteOpenHelper(getContext());        imfoText&#x3D; mView.findViewById(R.id.text_detail1);        button&#x3D; mView.findViewById(R.id.button2);    }}</code></pre><p>一个小坑： <strong>helper=new RecordSQLiteOpenHelper(getContext())</strong> ;<br>一开始初始化helper时，在<strong>onCreateView</strong>之前调用这句话，结果报错了，原因是Fragment在 <strong>onAttach（）</strong> 方法之前是没有和 <strong>activity</strong> 进行关联的，所以在这之前是获取不到上下文的，一定要在onCreate()之后的生命周期方法中才能调用getContext();</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> sqlite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>得到数据流的中位数</title>
      <link href="2020/07/11/de-dao-shu-ju-liu-de-zhong-wei-shu/"/>
      <url>2020/07/11/de-dao-shu-ju-liu-de-zhong-wei-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><img src="/2020/07/11/de-dao-shu-ju-liu-de-zhong-wei-shu/image.png" class=""><p>此题难点在于需要根据数据流的变化实时更新中位数，一开始想着用排序来解决，但是时间复杂度太高，于是引用了<strong>优先队列</strong>。优先队列的性质是小顶堆最小值永远在队首，大顶堆最大值永远在队首，这时我们就可以吧数据流分为两部分，一部分保存较小值，另一部分保存较大值，分别用小顶堆、大顶堆保存，那么我们需要的中位数就在两个优先队列的队首之间产生。<br>当数据数为<strong>偶数</strong>时，将数据插入小顶堆中，（确保插入的数为大顶堆队首指和这个数的较大者）<br>当数据数为<strong>奇数</strong>时，将数据插入大顶堆中，（确保插入的数为小顶堆队首指和这个数的较小者）<br>则中位数计算：<br>当数据数为<strong>奇数</strong>时，中位数等于小顶堆队首值；<br>当数据数为<strong>偶数</strong>时，中位数等于两个优先队列队首值的平均值。  </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>public class Solution {    PriorityQueue&lt;Integer&gt; low&#x3D;new PriorityQueue&lt;&gt;();    PriorityQueue&lt;Integer&gt; high&#x3D;new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            return  o2-o1;        }    });    int count &#x3D;0;    public void Insert(Integer num) {        if(count%2&#x3D;&#x3D;1){            low.offer(num);            int temp&#x3D;low.poll();            high.offer(temp);        }        else{            high.offer(num);            int temp&#x3D;high.poll();            low.offer(temp);        }        count++;    }    public Double GetMedian(){        if(count%2&#x3D;&#x3D;1){            return (double)low.peek();        }        else{            return (low.peek()+high.peek())&#x2F;2.0;        }    }}</code></pre><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView设置不同的item，并且为每个item设置监听事件</title>
      <link href="2020/07/10/recyclerview-she-zhi-bu-tong-de-item-bing-qie-wei-mei-ge-item-she-zhi-jian-ting-shi-jian/"/>
      <url>2020/07/10/recyclerview-she-zhi-bu-tong-de-item-bing-qie-wei-mei-ge-item-she-zhi-jian-ting-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>在做一个测试APP时用到的，记录一下。左方的RecyclerView是一个最简单的垂直分布的RecyclerView，右方则是一个fragment，包含着一个RecyclerView，并且每个item值变化时，上方的URL文本也随之变化，item的类型有三种，实现过程;  </p><img src="/2020/07/10/recyclerview-she-zhi-bu-tong-de-item-bing-qie-wei-mei-ge-item-she-zhi-jian-ting-shi-jian/1.png" class="" title="例图1"> <img src="/2020/07/10/recyclerview-she-zhi-bu-tong-de-item-bing-qie-wei-mei-ge-item-she-zhi-jian-ting-shi-jian/2.png" class="" title="例图2">  <h2 id="ShowFragment关键代码："><a href="#ShowFragment关键代码：" class="headerlink" title="ShowFragment关键代码："></a>ShowFragment关键代码：</h2><p>全局变量声明：</p><pre><code>private Uri.Builder mBuilder;    private String mTittle, mPath;    private View mView;    private TextView mTvContent, mTvTittle;    private RecyclerView mRecyclerView;    private Button btGo, btUpte;    private List&lt;ItemBean&gt; mItemBeanList &#x3D; new ArrayList&lt;&gt;();    private List&lt;String&gt; mValueList &#x3D; new ArrayList&lt;&gt;();</code></pre><p>数据初始化：</p><pre><code>private void initDate() {        for (int i &#x3D; 0; i &lt; mItemBeanList.size(); i++) {            mValueList.add(&quot;&quot;);        }        mBuilder &#x3D;new Uri.Builder()                .scheme(Path.scheme)                .authority(Path.pkgName)                .path(mPath);    }</code></pre><p>适配RecyclerView：</p><pre><code>private void initView() {        btGo &#x3D; mView.findViewById(R.id.bt_go);        btUpte &#x3D; mView.findViewById(R.id.bt_update);        mTvContent &#x3D; mView.findViewById(R.id.text_detial_one);        mTvTittle &#x3D; mView.findViewById(R.id.text_tittle);        mTvTittle.setText(&quot;-&quot; + mTittle + &quot;-&quot;);        mTvContent.setText(mBuilder.build().toString());        MultiItemsAdapter adapter &#x3D; new MultiItemsAdapter(this, getContext());        mRecyclerView &#x3D; mView.findViewById(R.id.rcv_vertical);        LinearLayoutManager managerVertical &#x3D; new LinearLayoutManager(getContext());        managerVertical.setOrientation(LinearLayoutManager.VERTICAL);        mRecyclerView.setLayoutManager(managerVertical);        mRecyclerView.addItemDecoration(new RecycleItemDecoration(getContext(), RecycleItemDecoration.VERTICAL_LIST));        mRecyclerView.setHasFixedSize(true);        mRecyclerView.setAdapter(adapter);        adapter.setDataList(mItemBeanList);    }</code></pre>  <p>为了接收itemBean的一个List，还要写一个接收List的构造函数：  </p><pre><code>public ShowFragment(String tittle, String content, List&lt;ItemBean&gt; list) {        mTittle &#x3D; tittle;        mPath &#x3D; content;        mItemBeanList &#x3D; list;    }</code></pre><p>其中的itemBean.java</p><pre><code>public class ItemBean {    private String tittle;    private String tittleEnglish;    private String content;    private int type;    &#x2F;&#x2F;...}</code></pre><p>ShowFragment实现一个OnItemClickListener的接口，作用是每个item中的值改变时，回调onTextChange（）方法，就可以实现改变RecyclerView外面的控件</p><pre><code>@Override    public void onTextChange(String text, int position) {        mValueList.set(position, text);        mBuilder.clearQuery();        for(int i&#x3D;0;i&lt;mValueList.size();i++)        {            if(!mValueList.get(i).equals(&quot;&quot;))            {                mBuilder.appendQueryParameter(mItemBeanList.get(i).getTittleEnglish(),mValueList.get(i));            }        }        setContentTv();    }}</code></pre><h2 id="MultiItemsAdapter关键代码："><a href="#MultiItemsAdapter关键代码：" class="headerlink" title="MultiItemsAdapter关键代码："></a>MultiItemsAdapter关键代码：</h2><p>全局变量及构造函数：</p><pre><code>public class MultiItemsAdapter extends RecyclerView.Adapter&lt;AbsViewHolder&gt; {    private OnItemClickListener mOnItemClickListener;    public OnItemClickListener getOnItemClickListener() {        return mOnItemClickListener;    }    private Context mContext;    private List&lt;ItemBean&gt; mList &#x3D; new ArrayList&lt;&gt;();    public MultiItemsAdapter(OnItemClickListener onItemClickListener, Context context) {        mOnItemClickListener &#x3D; onItemClickListener;        mContext &#x3D; context;    }    &#x2F;&#x2F;...}</code></pre><p>类中接口：</p><pre><code>public interface OnItemClickListener {        void onTextChange(String text, int position);    }}</code></pre>  <p>难点：在重写onCreateViewHolder（）和<strong>onBindViewHolder</strong>中，因为itemBean中有<strong>type</strong>这一成员变量，所以可以根据这个值来确定创建哪种item ,但是如果item种类多点，就会出现很多<strong>ifelse</strong>分支，这对我们开发来说是极其不好的，所以解决方法如下：</p><p>先创建一个抽象类AbsViewHold.java:</p><pre><code>public abstract class AbsViewHolder&lt;T extends ItemBean&gt; extends RecyclerView.ViewHolder {    private MultiItemsAdapter.OnItemClickListener mOnItemClickListener;    public AbsViewHolder(@NonNull View itemView) {        super(itemView);    }    public AbsViewHolder( MultiItemsAdapter multiItemsAdapter,@NonNull View itemView) {        super(itemView);        this.mOnItemClickListener&#x3D;multiItemsAdapter.getOnItemClickListener();    }    public abstract void bindData(T data,int position);}</code></pre>  <p>这里使用了<strong>泛型</strong>，目的是为了根据<strong>ItemData</strong>来确定<strong>ViewHolder</strong>，从而创建不同样式的item<br>创建三个不同的<strong>ViewHolder</strong>,对应三种不同的<strong>item</strong>，并且创建三个<strong>ItemData</strong>，都继承于ItemBean。  </p><p>ViewHoderA.java：</p><pre><code>public class ViewHolderA extends AbsViewHolder&lt;ItemDataA&gt; {    private MultiItemsAdapter.OnItemClickListener mOnItemClickListener;    TextView mTvTittle;    EditText mTvContent;    public ViewHolderA(MultiItemsAdapter multiItemsAdapter, View itemView) {        super(multiItemsAdapter,itemView);        this.mOnItemClickListener&#x3D;multiItemsAdapter.getOnItemClickListener();        mTvTittle &#x3D; itemView.findViewById(R.id.tv_tittle);        mTvContent &#x3D; itemView.findViewById(R.id.tv_content);    }    @Override    public void bindData(ItemDataA data, final int position) {        mTvTittle.setText(data.getTittle().toString());        mTvContent.setHint(data.getContent().toString());        mTvContent.addTextChangedListener(new TextWatcher() {            @Override            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {            }            @Override            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {            }            @Override            public void afterTextChanged(Editable editable) {                mOnItemClickListener.onTextChange(mTvContent.getText().toString(),position);            }        });    }}</code></pre>  <p>  ViewHoderB.java：  </p><pre><code>public class ViewHolderB extends AbsViewHolder&lt;ItemDataB&gt; {    private MultiItemsAdapter.OnItemClickListener mOnItemClickListener;    TextView mTvTittle;    EditText mTvContent;    public ViewHolderB(MultiItemsAdapter multiItemsAdapter, View itemView) {        super(multiItemsAdapter,itemView);        mOnItemClickListener &#x3D; multiItemsAdapter.getOnItemClickListener();        mTvTittle &#x3D; itemView.findViewById(R.id.tv_tittle2);        mTvContent &#x3D; itemView.findViewById(R.id.tv_content2);    }    @Override    public void bindData(ItemDataB data, final int position) {        mTvTittle.setText(data.getTittle().toString());        mTvContent.setHint(data.getContent().toString());        mTvContent.addTextChangedListener(new TextWatcher() {            @Override            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {            }            @Override            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {            }            @Override            public void afterTextChanged(Editable editable) {                mOnItemClickListener.onTextChange(mTvContent.getText().toString(),position);            }        });    }}</code></pre>  <p>  ViewHoderC.java：  </p><pre><code>public class ViewHolderC extends AbsViewHolder&lt;ItemDataC&gt; {    private MultiItemsAdapter.OnItemClickListener mOnItemClickListener;    TextView mTvTittle, mTvContent;    Switch aSwitch;    public ViewHolderC(MultiItemsAdapter multiItemsAdapter, View itemView) {        super(multiItemsAdapter,itemView);        mOnItemClickListener &#x3D; multiItemsAdapter.getOnItemClickListener();        mTvTittle &#x3D; itemView.findViewById(R.id.tv_tittle3);        mTvContent &#x3D; itemView.findViewById(R.id.tv_content3);        aSwitch&#x3D;itemView.findViewById(R.id.item_switch);    }    @Override    public void bindData(ItemDataC data, final int position) {        mTvTittle.setText(data.getTittle().toString());        mTvContent.setHint(data.getContent().toString());        if(data.getContent().toString().equals(&quot;true&quot;))            aSwitch.setChecked(true);        else            aSwitch.setChecked(false);        aSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {            @Override            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {                mTvContent.setText(b+&quot;&quot;);                mOnItemClickListener.onTextChange(b+&quot;&quot;,position);            }        });    }}</code></pre>  <p>这里的构造函数参数多了一个<strong>MultiItemsAdapter</strong>，这是为了将监听接口<strong>mOnItemClickListener</strong>传进来，** getOnItemClickListener() **方法在MultiItemsAdapter里实现就可以。<br>这样就实现了对每个Item监听，并且结合上文的接口、接口实现方法就可以更新RecyclerView外的控件。  </p><p>MultiItemsAdapter中重写onBindViewHolder（）方法，</p><pre><code>@Override    public void onBindViewHolder(@NonNull AbsViewHolder holder, int position) {        &#x2F;&#x2F;加一个position参数是为了监听文本框改变时，返回到实现类中，有确定的位置        holder.bindData(mList.get(position), position);    }</code></pre>  <p>直接调用** AbsViewHolder的bindData() <strong>方法，可以看到</strong> ViewHolderA，ViewHolderB,ViewHolderC <strong>中分别的</strong> bindData() <strong>方法，传入的参数是</strong> AbsViewHolder <strong>类型的，而各个实现bindData方法中的参数是</strong> ItemDataA / ItemDataB / ItemDataC <strong>,这里就是</strong>泛型<strong>的作用了，参数是超类，而传入时是ItemDataA，ItemDataB，ItemDataC这三种类型，根据这个参数创建相对应的</strong>ViewHolderA/ ViewHolderB / ViewHolderC**，从而实现创建不同样式的item的效果。</p><p>再看<strong>MultiItemsAdapter</strong>重写<strong>onCreateViewHolder</strong>的方法  </p><p>先建立映射关系，通过ArrayList：</p><pre><code>public List&lt;Class&lt;? extends ItemBean&gt;&gt; mItemTypes &#x3D; new ArrayList&lt;&gt;();    public List&lt;Class&lt;? extends AbsViewHolder&gt;&gt; mHolderTypes &#x3D; new ArrayList&lt;&gt;();    public List&lt;Integer&gt; mViewTypes &#x3D; new ArrayList&lt;&gt;();    {        registerItem(ItemDataA.class, ViewHolderA.class, R.layout.recycle_item1);        registerItem(ItemDataB.class, ViewHolderB.class, R.layout.recycle_item2);        registerItem(ItemDataC.class, ViewHolderC.class, R.layout.recycle_item3);    }    private void registerItem(Class&lt;? extends ItemBean&gt; dataClass, Class&lt;? extends AbsViewHolder&gt; holderClass, int layoutId) {        mItemTypes.add(dataClass);        mHolderTypes.add(holderClass);        mViewTypes.add(layoutId);    }   @NonNull    @Override    public AbsViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {        View view &#x3D; LayoutInflater.from(mContext).inflate(mViewTypes.get(viewType), parent, false);        Class holder &#x3D; mHolderTypes.get(viewType);  &#x2F;&#x2F;根据参数viewType来获得相对应的ViewHolder类的对象，                try {            Constructor constructor &#x3D; holder.getConstructor(MultiItemsAdapter.class, View.class);            Object absHolder &#x3D; constructor.newInstance(MultiItemsAdapter.this, view);            return (AbsViewHolder) absHolder;        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InstantiationException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        } catch (NoSuchMethodException e) {            e.printStackTrace();        }    }</code></pre><p>这里通过java中的<strong>反射</strong>机制，根据参数viewType来获得相对应的ViewHolderA / ViewHolderB / ViewHolderC类的对象，再通过<strong>getConstructor（）</strong>方法得到ViewHolderA / ViewHolderB /ViewHolderC的构造函数，通过构造函数创建对象实例返回，由此，避免了过多的ifelse分支。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的四种引用，强弱软虚，用到的场景</title>
      <link href="2020/04/15/java-de-si-chong-yin-yong-qiang-ruo-ruan-xu-yong-dao-de-chang-jing/"/>
      <url>2020/04/15/java-de-si-chong-yin-yong-qiang-ruo-ruan-xu-yong-dao-de-chang-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h2><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。<br>如下：</p><pre><code>                                  Object o&#x3D;new Object();   &#x2F;&#x2F;  强引用</code></pre><p>当内存空间不足，Java虚拟机宁愿抛出<strong>OutOfMemoryError</strong>错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：</p><pre><code> o&#x3D;null;     &#x2F;&#x2F; 帮助垃圾收集器回收此对象</code></pre><p> 显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。<br>举例：</p><pre><code>public void test(){    Object o&#x3D;new Object();    &#x2F;&#x2F; 省略其他操作}</code></pre><p>在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。<br>但是如果这个o是<strong>全局</strong>的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。<br>强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：</p><pre><code>private transient Object[] elementData;public void clear() {        modCount++;        &#x2F;&#x2F; Let gc do its work        for (int i &#x3D; 0; i &lt; size; i++)            elementData[i] &#x3D; null;        size &#x3D; 0;}</code></pre><p>在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。</p><h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现<strong>内存敏感</strong>的高速缓存。   </p><pre><code> String str&#x3D;new String(&quot;abc&quot;);                                     &#x2F;&#x2F; 强引用  SoftReference&lt;String&gt; softRef&#x3D;new SoftReference&lt;String&gt;(str);     &#x2F;&#x2F; 软引用</code></pre><p>  当内存不足时，等价于：</p><pre><code>If(JVM.内存不足()) {   str &#x3D; null;  &#x2F;&#x2F; 转换为软引用   System.gc(); &#x2F;&#x2F; 垃圾回收器进行回收}</code></pre><p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p><ul><li>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</li><li>如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出<br>这时候就可以使用软引用<pre><code>Browser prev &#x3D; new Browser();               &#x2F;&#x2F; 获取页面进行浏览SoftReference sr &#x3D; new SoftReference(prev); &#x2F;&#x2F; 浏览完毕后置为软引用    if(sr.get()!&#x3D;null){     rev &#x3D; (Browser) sr.get();           &#x2F;&#x2F; 还没有被回收器回收，直接获取}else{    prev &#x3D; new Browser();               &#x2F;&#x2F; 由于内存吃紧，所以对软引用的对象回收了    sr &#x3D; new SoftReference(prev);       &#x2F;&#x2F; 重新构建}</code></pre>这样就很好的解决了实际的问题。<br>软引用可以和一个<strong>引用队列</strong>（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</li></ul><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有<strong>更短暂</strong>的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个<strong>优先级很低</strong>的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。这个引用不会在对象的垃圾回收判断中产生任何附加的影响。比如说Thread中保存的ThreadLocal的全局映射，因为我们的Thread不想在ThreadLocal生命周期结束后还对其造成影响，所以应该使用弱引用，这个和缓存没有关系，只是为了防止内存泄漏所做的特殊操作。</p><h2 id="幽灵引用-虚引用"><a href="#幽灵引用-虚引用" class="headerlink" title="幽灵引用(虚引用) "></a>幽灵引用(虚引用) </h2><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和<strong>引用队列</strong> （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存后，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存回收后采取必要的行动。由于Object.finalize()方法的不安全性、低效性，常常使用虚引用完成对象回收后的资源释放工作。当你创建一个虚引用时要传入一个引用队列，如果引用队列中出现了你的虚引用，说明它已经被回收，那么你可以在其中做一些相关操作，主要是实现细粒度的内存控制。比如监视缓存，当缓存被回收后才申请新的缓存区。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么TCP连接三次握手而TCP断开连接四次分手？</title>
      <link href="2020/03/10/wei-shi-me-tcp-lian-jie-san-ci-wo-shou-er-tcp-duan-kai-lian-jie-si-ci-fen-shou/"/>
      <url>2020/03/10/wei-shi-me-tcp-lian-jie-san-ci-wo-shou-er-tcp-duan-kai-lian-jie-si-ci-fen-shou/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><img src="/2020/03/10/wei-shi-me-tcp-lian-jie-san-ci-wo-shou-er-tcp-duan-kai-lian-jie-si-ci-fen-shou/1.png" class=""><p>所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要<strong>客户端</strong>和<strong>服务器</strong>总共发送3个包。  </p><p>三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。</p><ul><li><p>第一次握手:<br>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</p></li><li><p>第二次握手:<br>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p></li><li><p>第三次握手.<br>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</p></li></ul><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>在三次握手过程中，服务器发送<strong>SYN-ACK</strong>之后，收到客户端的<strong>ACK</strong>之前的TCP连接称为<strong>半连接(half-open connect)</strong>.此时服务器处于<strong>Syn_RECV</strong>状态.当收到ACK后，服务器转入<strong>ESTABLISHED</strong>状态.</p><p> Syn攻击就是 攻击客户端 在短时间内伪造<strong>大量不存在的IP地址</strong>，向服务器<strong>不断地发送syn包</strong>，服务器回复确认包，并等待客户的确认，由于源地址是<strong>不存在</strong>的，服务器需要不断的重发直至<strong>超时</strong>，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p><p> Syn攻击是一个典型的<strong>DDOS</strong>攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是<strong>随机</strong>的，基本上可以断定这是一次<strong>SYN攻击</strong>.在Linux下可以如下命令检测是否被Syn攻击</p><pre><code>netstat -n -p TCP | grep SYN_RECV</code></pre><p>一般较新的<strong>TCP/IP协议栈</strong>都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有<strong>SynAttackProtect</strong>保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.</p><p>但是不能完全防范syn攻击。</p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>TCP的连接的拆除需要发送四个包，因此称为**四次挥手(four-way handshake)**。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><img src="/2020/03/10/wei-shi-me-tcp-lian-jie-san-ci-wo-shou-er-tcp-duan-kai-lian-jie-si-ci-fen-shou/2.png" class=""><p>TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:</p><p>位码即tcp标志位,有6种标示:</p><ul><li>SYN(synchronous建立联机) </li><li>ACK(acknowledgement 确认) </li><li>PSH(push传送) FIN(finish结束) </li><li>RST(reset重置) URG(urgent紧急)</li><li>Sequence number(顺序号码)</li><li>Acknowledge number(确认号码)</li></ul><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；</p><p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包</p><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</p><p>完成三次握手，主机A与主机B开始传送数据。</p><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手：建立连接时，客户端发送<strong>syn</strong>包(syn=j)到服务器，并进入<strong>SYN_SEND</strong>状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即<strong>SYN+ACK</strong>包，此时服务器 进入<strong>SYN_RECV</strong>状态；<br>第三次握手：客户端收到服务器的<strong>SYN＋ACK</strong>包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 <strong>ESTABLISHED</strong>状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据.</p><h3 id="四次分手："><a href="#四次分手：" class="headerlink" title="四次分手："></a>四次分手：</h3><p>由于TCP连接是<strong>全双工</strong>的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个<strong>FIN</strong>来终止这个方向的连接。收 到一个<strong>FIN</strong>只意味着这一方向上没有数据流动，一个TCP连接在收到一个<strong>FIN</strong>后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ul><li><p>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。</p></li><li><p>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。</p></li><li><p>服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。</p></li><li><p>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。</p></li></ul><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><h3 id="1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"><a href="#1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"></a>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h3><p>这是因为服务端的<strong>LISTEN</strong>状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作 用）放在一个报文里来发送。但关闭连接时，当收到对方的<strong>FIN</strong>报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送<strong>FIN</strong>报文给对方来表示你同意现在可以关闭连接了所以它这里的ACK报文和FIN报文多数情况下都是<strong>分开发送</strong>的。</p><h3 id="2．为什么TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？"><a href="#2．为什么TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？" class="headerlink" title="2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？"></a>2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</h3><p>这是因为虽然双方都同意关闭连接了,而且握手的4个报文也都协调和发送完毕，按理可以直接回到<strong>CLOSED</strong>状态（就好比 从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因 此对方处于<strong>LAST_ACK</strong>状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个<strong>TIME_WAIT</strong>状态的作用就是用来重发 可能丢失的ACK报文。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object的公用方法</title>
      <link href="2020/02/20/object-de-gong-yong-fang-fa/"/>
      <url>2020/02/20/object-de-gong-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>保护方法，实现对象的浅复制，只有实现了<strong>Cloneable</strong>接口才可以调用该方法，否则抛出CloneNotSupportedException异常  </p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>在Object中与==是一样的，子类一般需要重写该方法</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到</p><h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><p>final方法，获得运行时类型</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 <br>调用该方法后当前线程进入睡眠状态，直到以下事件发生： </p><ol><li>其他线程调用了该对象的notify方法 </li><li>其他线程调用了该对象的notifyAll方法 </li><li>其他线程调用了interrupt中断该线程 </li><li>时间间隔到了 <br>此时该线程就可以被调度了，如果是被中断的话就抛出一个<strong>InterruptedException</strong>异常</li></ol><h2 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h2><p>唤醒在该对象上等待的某个线程</p><h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h2><p>唤醒在该对象上等待的所有线程</p><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>转换成字符串，一般子类都有重写，否则打印句柄</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/01/05/hello-world/"/>
      <url>2020/01/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"531fdf9b5545166cc613","clientSecret":"ab49d6454dc28018f5f2c2651e5a626bc7064c66","repo":"gitalk","owner":"huangf20","admin":["huangf20"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
